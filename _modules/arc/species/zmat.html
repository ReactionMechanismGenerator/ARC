

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>arc.species.zmat &mdash; ARC 1.1.0 Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> ARC
          

          
          </a>

          
            
            
              <div class="version">
                1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../running.html">Running ARC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">ARCâ€™s API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools.html">Standalone tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../media.html">Media</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">How to cite ARC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../licence.html">Licence</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ARC</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>arc.species.zmat</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for arc.species.zmat</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A module for representing and manipulating `Z matrices &lt;https://en.wikipedia.org/wiki/Z-matrix_(chemistry)&gt;`_</span>
<span class="sd">(internal coordinates).</span>

<span class="sd">An example for a (consolidated) zmat representation for methane::</span>

<span class="sd">    {&#39;symbols&#39;: (&#39;C&#39;, &#39;H&#39;, &#39;H&#39;, &#39;H&#39;, &#39;H&#39;),</span>
<span class="sd">     &#39;coords&#39;: ((None, None, None),</span>
<span class="sd">                (&#39;R_1_0&#39;, None, None),</span>
<span class="sd">                (&#39;R_2|3|4_1|2|3&#39;, &#39;A_2|3|4_1|2|3_0|0|0&#39;, None),</span>
<span class="sd">                (&#39;R_2|3|4_1|2|3&#39;, &#39;A_2|3|4_1|2|3_0|0|0&#39;, &#39;D_3_2_0_1&#39;),</span>
<span class="sd">                (&#39;R_2|3|4_1|2|3&#39;, &#39;A_2|3|4_1|2|3_0|0|0&#39;, &#39;D_4_3_0_2&#39;)),</span>
<span class="sd">     &#39;vars&#39;: {&#39;R_1_0&#39;: 1.09125,</span>
<span class="sd">              &#39;D_3_2_0_1&#39;: 120.0,</span>
<span class="sd">              &#39;D_4_3_0_2&#39;: 240.0,</span>
<span class="sd">              &#39;R_2|3|4_1|2|3&#39;: 1.78200,</span>
<span class="sd">              &#39;A_2|3|4_1|2|3_0|0|0&#39;: 35.26439},</span>
<span class="sd">     &#39;map&#39;: {0: 0, 1: 1, 2: 2, 3: 3, 4: 4},</span>
<span class="sd">     }</span>

<span class="sd">Isotope information is not saved in the zmat, it exists in the xyz dict,</span>
<span class="sd">and can be attained using the zmat map if needed.</span>

<span class="sd">Note that a 180 (or 0) degree for an angle in a Z matrix is not allowed, since a GIC (Generalized Internal Coordinates)</span>
<span class="sd">optimization has no defined derivative at 180 degrees. Instead, a dummy atom &#39;X&#39; is used.</span>
<span class="sd">Dihedral angles may have any value.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">rmgpy.molecule.molecule</span> <span class="kn">import</span> <span class="n">Molecule</span>

<span class="kn">from</span> <span class="nn">arc.common</span> <span class="kn">import</span> <span class="n">get_logger</span><span class="p">,</span> <span class="n">is_angle_linear</span><span class="p">,</span> <span class="n">key_by_val</span><span class="p">,</span> <span class="n">determine_top_group_indices</span>
<span class="kn">from</span> <span class="nn">arc.exceptions</span> <span class="kn">import</span> <span class="n">ZMatError</span>
<span class="kn">from</span> <span class="nn">arc.species.vectors</span> <span class="kn">import</span> <span class="n">calculate_param</span><span class="p">,</span> <span class="n">get_vector_length</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">rmgpy.molecule.molecule</span> <span class="kn">import</span> <span class="n">Atom</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">()</span>

<span class="n">DEFAULT_CONSOLIDATION_R_TOL</span> <span class="o">=</span> <span class="mf">1e-4</span>
<span class="n">DEFAULT_CONSOLIDATION_A_TOL</span> <span class="o">=</span> <span class="mf">1e-3</span>
<span class="n">DEFAULT_CONSOLIDATION_D_TOL</span> <span class="o">=</span> <span class="mf">1e-3</span>
<span class="n">DEFAULT_COMPARISON_R_TOL</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># Angstrom</span>
<span class="n">DEFAULT_COMPARISON_A_TOL</span> <span class="o">=</span> <span class="mf">2.0</span>  <span class="c1"># degrees</span>
<span class="n">DEFAULT_COMPARISON_D_TOL</span> <span class="o">=</span> <span class="mf">2.0</span>  <span class="c1"># degrees</span>
<span class="n">TOL_180</span> <span class="o">=</span> <span class="mf">0.9</span>  <span class="c1"># degrees</span>
<span class="n">KEY_FROM_LEN</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;D&#39;</span><span class="p">}</span>


<div class="viewcode-block" id="xyz_to_zmat"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.xyz_to_zmat">[docs]</a><span class="k">def</span> <span class="nf">xyz_to_zmat</span><span class="p">(</span><span class="n">xyz</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                <span class="n">mol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Molecule</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">consolidate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">consolidation_tols</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">fragments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a z-matrix from cartesian coordinates.</span>
<span class="sd">    The zmat is a dictionary with the following keys:</span>
<span class="sd">    - &#39;symbols&#39;: a tuple of strings representing atomic symbols; defined as a list and converted to a tuple</span>
<span class="sd">    - &#39;coords&#39;: a tuple of tuples representing internal coordinates; defined as a list and converted to a tuple</span>
<span class="sd">    - &#39;vars&#39;: a dictionary of all variables defined for the coordinates</span>
<span class="sd">    - &#39;map&#39;: a dictionary connecting atom indices in the zmat (keys) to atom indices in the mol/coords (values)</span>
<span class="sd">    This function assumes ``xyz`` has no dummy atoms.</span>
<span class="sd">    This function does not attempt to resolve constrain locks, and assumes only few non-circular constraints were given.</span>

<span class="sd">    Args:</span>
<span class="sd">        xyz (dict): The xyz coordinates.</span>
<span class="sd">        mol (Molecule, optional): The corresponding RMG Molecule. If given, the bonding information will be used</span>
<span class="sd">                                  to generate a more meaningful zmat.</span>
<span class="sd">        constraints (dict, optional): Accepted keys are:</span>
<span class="sd">                                      &#39;R_atom&#39;, &#39;R_group&#39;,</span>
<span class="sd">                                      &#39;A_atom&#39;, &#39;A_group&#39;,</span>
<span class="sd">                                      &#39;D_atom&#39;, &#39;D_group&#39;.</span>
<span class="sd">                                      &#39;R&#39;, &#39;A&#39;, and &#39;D&#39; are constrain distances, angles, and dihedrals, respectively.</span>
<span class="sd">                                      Values are lists of atom index tuples (0-indexed). The atom indices order matters.</span>
<span class="sd">                                      Specifying &#39;_atom&#39; will cause only the first atom in the specified list values</span>
<span class="sd">                                      to translate/rotate if the corresponding zmat parameter is changed.</span>
<span class="sd">                                      Specifying &#39;_group&#39; will cause the entire group connected to the first atom</span>
<span class="sd">                                      to translate/rotate if the corresponding zmat parameter is changed.</span>
<span class="sd">                                      Specifying &#39;_groups&#39; (only valid for D) will cause the groups connected to</span>
<span class="sd">                                      the first two atoms to translate/rotate if the corresponding parameter is changed.</span>
<span class="sd">                                      Note that &#39;D_groups&#39; should not be passed directly to this function, but to</span>
<span class="sd">                                      arc.species.converter.modify_coords() instead (it is a composite constraint).</span>
<span class="sd">        consolidate (bool, optional): Whether to consolidate the zmat after generation, ``True`` to consolidate.</span>
<span class="sd">        consolidation_tols (dict, optional): Keys are &#39;R&#39;, &#39;A&#39;, &#39;D&#39;, values are floats representing absolute tolerance</span>
<span class="sd">                                             for consolidating almost equal internal coordinates.</span>
<span class="sd">        fragments (List[List[int]], optional):</span>
<span class="sd">            Fragments represented by the species, i.e., as in a VdW well or a TS.</span>
<span class="sd">            Entries are atom index lists of all atoms in a fragment, each list represents a different fragment.</span>
<span class="sd">            indices are 0-indexed.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If the zmat could not be generated.</span>

<span class="sd">    Returns: Dict[str, tuple]</span>
<span class="sd">        The z-matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fragments</span> <span class="o">=</span> <span class="n">fragments</span> <span class="ow">or</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])))]</span>
    <span class="n">constraints</span> <span class="o">=</span> <span class="n">constraints</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="s1">&#39;group&#39;</span> <span class="ow">in</span> <span class="n">constraint_key</span> <span class="k">for</span> <span class="n">constraint_key</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot generate a constrained zmat without mol. Got mol=None and constraints=</span><span class="se">\n</span><span class="si">{</span><span class="n">constraints</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">constraint_list</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">constraint_tuple</span> <span class="ow">in</span> <span class="n">constraint_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">constraint_tuple</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The following constraints (containing atom index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">) are invalid for &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;a molecule with only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span><span class="si">}</span><span class="s1"> atoms:</span><span class="se">\n</span><span class="si">{</span><span class="n">constraints</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The following constraints (containing atom index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">) are invalid for &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;coordinates with only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> atoms:</span><span class="se">\n</span><span class="si">{</span><span class="n">constraints</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">zmat</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;symbols&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(),</span> <span class="s1">&#39;coords&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(),</span> <span class="s1">&#39;vars&#39;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(),</span> <span class="s1">&#39;map&#39;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">()}</span>
    <span class="n">atom_order</span> <span class="o">=</span> <span class="n">get_atom_order</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">constraints_dict</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span> <span class="n">fragments</span><span class="o">=</span><span class="n">fragments</span><span class="p">)</span>
    <span class="n">connectivity</span> <span class="o">=</span> <span class="n">get_connectivity</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">)</span> <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">skipped_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># atoms for which constrains are applied</span>
    <span class="k">for</span> <span class="n">atom_index</span> <span class="ow">in</span> <span class="n">atom_order</span><span class="p">:</span>
        <span class="n">zmat</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">skipped</span> <span class="o">=</span> <span class="n">_add_nth_atom_to_zmat</span><span class="p">(</span>
            <span class="n">zmat</span><span class="o">=</span><span class="n">zmat</span><span class="p">,</span>
            <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
            <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
            <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])),</span>
            <span class="n">atom_index</span><span class="o">=</span><span class="n">atom_index</span><span class="p">,</span>
            <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
            <span class="n">fragments</span><span class="o">=</span><span class="n">fragments</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">skipped_atoms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">skipped</span><span class="p">)</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_atoms</span><span class="p">):</span>
        <span class="n">num_of_skipped_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_atoms</span><span class="p">)</span>
        <span class="n">indices_to_pop</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">skipped_atoms</span><span class="p">):</span>
            <span class="n">zmat</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">skipped</span> <span class="o">=</span> <span class="n">_add_nth_atom_to_zmat</span><span class="p">(</span>
                <span class="n">zmat</span><span class="o">=</span><span class="n">zmat</span><span class="p">,</span>
                <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])),</span>
                <span class="n">atom_index</span><span class="o">=</span><span class="n">atom_index</span><span class="p">,</span>
                <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
                <span class="n">fragments</span><span class="o">=</span><span class="n">fragments</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped</span><span class="p">):</span>
                <span class="c1"># This atom was not skipped this time, remove it from the skipped atoms list....</span>
                <span class="n">indices_to_pop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">indices_to_pop</span><span class="p">):</span>
            <span class="n">skipped_atoms</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_of_skipped_atoms</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">skipped_atoms</span><span class="p">):</span>
            <span class="c1"># No atoms were popped from the skipped atoms list when iterating through all skipped atoms.</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not generate the zmat, skipped atoms could not be assigned, there&#39;s probably &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;a constraint lock. The partial zmat is:</span><span class="se">\n</span><span class="si">{</span><span class="n">zmat</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">skipped atoms are:</span><span class="se">\n</span><span class="si">{</span><span class="n">skipped_atoms</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">consolidate</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">constraints</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">zmat</span> <span class="o">=</span> <span class="n">consolidate_zmat</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">consolidation_tols</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="n">ZMatError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not consolidate zmat, got:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Generating zmat without consolidation.&#39;</span><span class="p">)</span>

    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">zmat</span></div>


<div class="viewcode-block" id="determine_r_atoms"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.determine_r_atoms">[docs]</a><span class="k">def</span> <span class="nf">determine_r_atoms</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]],</span>
                      <span class="n">xyz</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                      <span class="n">connectivity</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                      <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="n">r_constraint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">a_constraint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">d_constraint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">trivial_assignment</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">fragments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the atoms for defining the distance R.</span>
<span class="sd">    This should be in the form: [n, &lt;some other atom already in the zmat&gt;]</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        xyz (dict): The xyz dict.</span>
<span class="sd">        connectivity (dict): The atoms connectivity (keys are indices in the mol/xyz).</span>
<span class="sd">        n (int): The 0-index of the atom in the zmat to be added.</span>
<span class="sd">        atom_index (int): The 0-index of the atom in the molecule or cartesian coordinates to be added.</span>
<span class="sd">                          (``n`` and ``atom_index`` refer to the same atom, but it might have different indices</span>
<span class="sd">                          in the zmat and the molecule/xyz)</span>
<span class="sd">        r_constraint (tuple, optional): R-type constraints. The atom index to which the atom being checked is</span>
<span class="sd">                                        constrained. ``None`` if it is not constrained.</span>
<span class="sd">        a_constraint (tuple, optional): A-type constraints. The atom indices to which the atom being checked is</span>
<span class="sd">                                        constrained. ``None`` if it is not constrained.</span>
<span class="sd">        d_constraint (tuple, optional): D-type constraints. The atom indices to which the atom being checked is</span>
<span class="sd">                                        constrained. ``None`` if it is not constrained.</span>
<span class="sd">        trivial_assignment (bool, optional): Whether to attempt assigning atoms without considering connectivity</span>
<span class="sd">                                             if the connectivity assignment fails.</span>
<span class="sd">        fragments (List[List[int]], optional):</span>
<span class="sd">            Fragments represented by the species, i.e., as in a VdW well or a TS.</span>
<span class="sd">            Entries are atom index lists of all atoms in a fragment, each list represents a different fragment.</span>
<span class="sd">            indices are 0-indexed.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If the R atoms could not be determined.</span>

<span class="sd">    Returns: Optional[List[int]]</span>
<span class="sd">        The 0-indexed z-mat R atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_atom_in_new_fragment</span><span class="p">(</span><span class="n">atom_index</span><span class="o">=</span><span class="n">atom_index</span><span class="p">,</span> <span class="n">zmat</span><span class="o">=</span><span class="n">zmat</span><span class="p">,</span> <span class="n">fragments</span><span class="o">=</span><span class="n">fragments</span><span class="p">):</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># This is the 1st atom added to the zmat, there&#39;s no distance definition here.</span>
        <span class="n">r_atoms</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="p">[</span><span class="n">r_constraint</span><span class="p">,</span> <span class="n">a_constraint</span><span class="p">,</span> <span class="n">d_constraint</span><span class="p">]):</span>
        <span class="c1"># 1. Always use the constraint if given.</span>
        <span class="k">if</span> <span class="n">r_constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">r_constraint</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">elif</span> <span class="n">a_constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">a_constraint</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">elif</span> <span class="n">d_constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">d_constraint</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
    <span class="k">elif</span> <span class="n">connectivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># 2. Use connectivity if the atom is not constrained.</span>
        <span class="n">r_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">atom_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Keys are neighbor atom indices, values are tuples of depth and linearity.</span>
        <span class="k">for</span> <span class="n">atom_c</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_index</span><span class="p">]:</span>
            <span class="c1"># Code adopted from arc.common.determine_top_group_indices():.</span>
            <span class="n">linear</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Assume the chain from atom_index towards atom_c is linear unless otherwise proven.</span>
            <span class="n">explored_atom_list</span><span class="p">,</span> <span class="n">atom_list_to_explore1</span><span class="p">,</span> <span class="n">atom_list_to_explore2</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom_index</span><span class="p">],</span> <span class="p">[</span><span class="n">atom_c</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_list_to_explore1</span> <span class="o">+</span> <span class="n">atom_list_to_explore2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">atom3</span> <span class="ow">in</span> <span class="n">atom_list_to_explore1</span><span class="p">:</span>
                    <span class="n">top</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">atom3</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">atom4</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom3</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">atom4</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored_atom_list</span> <span class="ow">and</span> <span class="n">atom4</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_list_to_explore2</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">atom4</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;Cl&#39;</span><span class="p">,</span> <span class="s1">&#39;Br&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]:</span>
                                    <span class="c1"># Append w/o further exploration.</span>
                                    <span class="n">top</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom4</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">atom_list_to_explore2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom4</span><span class="p">)</span>  <span class="c1"># Explore it further.</span>
                    <span class="n">explored_atom_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom3</span><span class="p">)</span>  <span class="c1"># Mark as explored.</span>
                <span class="n">atom_list_to_explore1</span><span class="p">,</span> <span class="n">atom_list_to_explore2</span> <span class="o">=</span> <span class="n">atom_list_to_explore2</span><span class="p">,</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># Calculate the angle formed with the index_atom.</span>
                    <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">],</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">atom_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">):</span>
                        <span class="n">linear</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="c1"># If it&#39;s not linear and there are 3 or more atoms, we have all the info that we need.</span>
                            <span class="k">break</span>
            <span class="n">atom_dict</span><span class="p">[</span><span class="n">atom_c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">),</span> <span class="n">linear</span><span class="p">)</span>
        <span class="n">long_non_linear</span><span class="p">,</span> <span class="n">long_linear</span><span class="p">,</span> <span class="n">two_non_linear</span><span class="p">,</span> <span class="n">two_linear</span><span class="p">,</span> <span class="n">one</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">atom_c</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">atom_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">atom_c</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">zmat_index_c</span> <span class="o">=</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom_c</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dummy</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">zmat_index_c</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">long_non_linear</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zmat_index_c</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">long_linear</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zmat_index_c</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">two_non_linear</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zmat_index_c</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">two_linear</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zmat_index_c</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">one</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zmat_index_c</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">long_non_linear</span><span class="p">):</span>
            <span class="n">r_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">long_non_linear</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_non_linear</span><span class="p">):</span>
            <span class="n">r_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">two_non_linear</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">long_linear</span><span class="p">):</span>
            <span class="n">r_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">long_linear</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_linear</span><span class="p">):</span>
            <span class="n">r_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">two_linear</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">one</span><span class="p">):</span>
            <span class="n">r_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">one</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">r_atoms</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">trivial_assignment</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not come up with two unique r_atoms from connectivity (r_atoms = </span><span class="si">{</span><span class="n">r_atoms</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trivial_assignment</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">r_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">trivial_assignment</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r_atoms</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># 3. Use trivial atom assigment if constraint and connectivity were not given.</span>
        <span class="n">r_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">r_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dummy</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                    <span class="n">r_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">r_atoms</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not come up with two unique non-dummy r_atoms (r_atoms = </span><span class="si">{</span><span class="n">r_atoms</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">r_atoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The reference R atom </span><span class="si">{</span><span class="n">r_atoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> for the index atom </span><span class="si">{</span><span class="n">atom_index</span><span class="si">}</span><span class="s1"> has not been &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;added to the zmat yet. Added atoms are (zmat index: xyz index): </span><span class="si">{</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">r_atoms</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not come up with two unique r_atoms (r_atoms = </span><span class="si">{</span><span class="n">r_atoms</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r_atoms</span></div>


<div class="viewcode-block" id="determine_a_atoms"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.determine_a_atoms">[docs]</a><span class="k">def</span> <span class="nf">determine_a_atoms</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]],</span>
                      <span class="n">coords</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                      <span class="n">connectivity</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                      <span class="n">r_atoms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                      <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="n">a_constraint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">d_constraint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">a_constraint_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">trivial_assignment</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">fragments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the atoms for defining the angle A.</span>
<span class="sd">    This should be in the form: [n, r_atoms[1], &lt;some other atom already in the zmat&gt;]</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        coords (list, tuple): Just the &#39;coords&#39; part of the xyz dict.</span>
<span class="sd">        connectivity (dict): The atoms connectivity (keys are indices in the mol/xyz).</span>
<span class="sd">        r_atoms (list): The determined r_atoms.</span>
<span class="sd">        n (int): The 0-index of the atom in the zmat to be added.</span>
<span class="sd">        atom_index (int): The 0-index of the atom in the molecule or cartesian coordinates to be added.</span>
<span class="sd">                          (``n`` and ``atom_index`` refer to the same atom, but it might have different indices</span>
<span class="sd">                          in the zmat and the molecule/xyz)</span>
<span class="sd">        a_constraint (tuple, optional): A-type constraints. The atom indices to which the atom being checked is</span>
<span class="sd">                                        constrained. ``None`` if it is not constrained.</span>
<span class="sd">        d_constraint (tuple, optional): D-type constraints. The atom indices to which the atom being checked is</span>
<span class="sd">                                        constrained. ``None`` if it is not constrained.</span>
<span class="sd">        a_constraint_type (str, optional): The A constraint type (&#39;A_atom&#39;, or &#39;A_group&#39;).</span>
<span class="sd">        trivial_assignment (bool, optional): Whether to attempt assigning atoms without considering connectivity</span>
<span class="sd">                                             if the connectivity assignment fails.</span>
<span class="sd">        fragments (List[List[int]], optional):</span>
<span class="sd">            Fragments represented by the species, i.e., as in a VdW well or a TS.</span>
<span class="sd">            Entries are atom index lists of all atoms in a fragment, each list represents a different fragment.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If the A atoms could not be determined.</span>
<span class="sd">            indices are 0-indexed.</span>

<span class="sd">    Returns: Optional[List[int]]</span>
<span class="sd">        The 0-indexed z-mat A atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">r_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_atom_in_new_fragment</span><span class="p">(</span><span class="n">atom_index</span><span class="o">=</span><span class="n">atom_index</span><span class="p">,</span> <span class="n">zmat</span><span class="o">=</span><span class="n">zmat</span><span class="p">,</span>
                                                       <span class="n">fragments</span><span class="o">=</span><span class="n">fragments</span><span class="p">,</span> <span class="n">skip_atoms</span><span class="o">=</span><span class="n">r_atoms</span><span class="p">):</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">r_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;r_atoms must be a list of length 2, got </span><span class="si">{</span><span class="n">r_atoms</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># This is the 1st or 2nd atom added to the zmat, there&#39;s no angle definition here.</span>
        <span class="n">a_atoms</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">a_constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># always use the constraint if given</span>
        <span class="k">if</span> <span class="n">a_constraint_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;A_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;A_group&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Got an invalid A constraint type &quot;</span><span class="si">{</span><span class="n">a_constraint_type</span><span class="si">}</span><span class="s1">&quot; for </span><span class="si">{</span><span class="n">a_constraint</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">a_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">a_constraint</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
    <span class="k">elif</span> <span class="n">d_constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># consider d_constraint for consistency if a_constraint is None</span>
        <span class="n">a_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">d_constraint</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="n">connectivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">a_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">r_atoms</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">a_atoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">+</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_index</span><span class="p">]:</span>
            <span class="c1"># An angle should be defined between an atom, its neighbor, and its neighbor&#39;s neighbor.</span>
            <span class="k">if</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">atom</span> <span class="o">!=</span> <span class="n">atom_index</span> <span class="ow">and</span> <span class="n">zmat_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_atoms</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dummy</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">zmat_index</span><span class="p">):</span>
                    <span class="c1"># Check whether this atom (B) is part of a linear chain. If it is, try to correctly determine</span>
                    <span class="c1"># dihedrals in this molecule w/o this atom, otherwise it&#39;s meaningless, and the zmat looses info.</span>
                    <span class="c1">#</span>
                    <span class="c1">#                     D (atom_index, r_atoms[0])</span>
                    <span class="c1">#                    /</span>
                    <span class="c1">#    E -- A -- B -- C  (r_atoms[1])</span>
                    <span class="c1">#   /</span>
                    <span class="c1">#  F          (B is the atom considered here, corresponding to &#39;atom&#39; / &#39;zmat_index&#39;)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">atom_b</span><span class="p">,</span> <span class="n">atom_c</span> <span class="o">=</span> <span class="n">atom</span><span class="p">,</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">r_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">connectivity</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                        <span class="n">num_of_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">connectivity</span><span class="p">[</span><span class="n">atom_b</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="n">num_of_neighbors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># Atom B is only connected to C, no need to intervene.</span>
                            <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">num_of_neighbors</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="c1"># Atom B might be in a linear chain, determine the A -- B -- C angle.</span>
                            <span class="n">b_neighbors</span> <span class="o">=</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_b</span><span class="p">]</span>
                            <span class="n">atom_a</span> <span class="o">=</span> <span class="n">b_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">b_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">atom_c</span> <span class="k">else</span> <span class="n">b_neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">atom_a</span><span class="p">,</span> <span class="n">atom_b</span><span class="p">,</span> <span class="n">atom_c</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">):</span>
                                <span class="c1"># A -- B -- C is linear, change indices and test angle E -- A -- B instead.</span>
                                <span class="n">atom_c</span> <span class="o">=</span> <span class="n">atom_b</span>
                                <span class="n">atom_b</span> <span class="o">=</span> <span class="n">atom_a</span>
                            <span class="k">elif</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom_b</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_atoms</span><span class="p">:</span>
                                <span class="c1"># A -- B -- C is not linear, use atom B.</span>
                                <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom_b</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">num_of_neighbors</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="c1"># Atom B does not necessarily lead to a linear A -- B -- C chain, no need to intervene.</span>
                            <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom_b</span><span class="p">)</span>
                            <span class="k">break</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Don&#39;t loop forever.</span>
                    <span class="n">a_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zmat_index</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">a_atoms</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">trivial_assignment</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not come up with three unique a_atoms from connectivity (a_atoms = </span><span class="si">{</span><span class="n">a_atoms</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trivial_assignment</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">a_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">trivial_assignment</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a_atoms</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">a_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">r_atoms</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
            <span class="c1"># Check whether this atom (B) is part of a linear chain. If it is, try to correctly determine</span>
            <span class="c1"># dihedrals in this molecule w/o this atom, otherwise it&#39;s meaningless, and the zmat looses info.</span>
            <span class="c1">#</span>
            <span class="c1">#                     D (atom_index, r_atoms[0])</span>
            <span class="c1">#                    /</span>
            <span class="c1">#    E -- A -- B -- C  (r_atoms[1])</span>
            <span class="c1">#   /</span>
            <span class="c1">#  F          (B is the atom considered here)</span>
            <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_atoms</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dummy</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="n">zmat_index</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">atom_b</span><span class="p">,</span> <span class="n">atom_c</span> <span class="o">=</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">r_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">atom_a</span> <span class="o">=</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">atom_a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">atom_b</span><span class="p">,</span> <span class="n">atom_c</span><span class="p">]</span> \
                            <span class="ow">and</span> <span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dummy</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                 <span class="ow">or</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">atom_a</span><span class="p">,</span> <span class="n">atom_b</span><span class="p">,</span> <span class="n">atom_c</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">):</span>
                            <span class="c1"># A -- B -- C is linear, change indices and test angle E -- A -- B.</span>
                            <span class="n">atom_b</span> <span class="o">=</span> <span class="n">atom_a</span>
                        <span class="k">elif</span> <span class="n">zmat_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_atoms</span><span class="p">:</span>
                            <span class="c1"># A -- B -- C is not linear, use atom B.</span>
                            <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom_b</span><span class="p">)</span>
                            <span class="n">a_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zmat_index</span><span class="p">)</span>
                            <span class="k">break</span>
                    <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># Don&#39;t loop forever.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">zmat_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_atoms</span><span class="p">:</span>
            <span class="n">a_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zmat_index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">a_atom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">a_atom</span> <span class="ow">in</span> <span class="n">a_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The reference A atom in </span><span class="si">{</span><span class="n">a_atoms</span><span class="si">}</span><span class="s1"> for the index atom </span><span class="si">{</span><span class="n">atom_index</span><span class="si">}</span><span class="s1"> has not been &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;added to the zmat yet. Added atoms are (zmat index: xyz index): </span><span class="si">{</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">a_atoms</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not come up with three unique a_atoms (a_atoms = </span><span class="si">{</span><span class="n">a_atoms</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a_atoms</span></div>


<div class="viewcode-block" id="determine_d_atoms"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.determine_d_atoms">[docs]</a><span class="k">def</span> <span class="nf">determine_d_atoms</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]],</span>
                      <span class="n">xyz</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                      <span class="n">coords</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                      <span class="n">connectivity</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                      <span class="n">a_atoms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                      <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="n">d_constraint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">d_constraint_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">specific_atom</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">dummy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">fragments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the atoms for defining the dihedral angle D.</span>
<span class="sd">    This should be in the form: [n, a_atoms[1], a_atoms[2], &lt;some other atom already in the zmat&gt;]</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        xyz (dict): The xyz dict.</span>
<span class="sd">        coords (list, tuple): Just the &#39;coords&#39; part of the xyz dict.</span>
<span class="sd">        connectivity (dict): The atoms connectivity (keys are indices in the mol/xyz).</span>
<span class="sd">        a_atoms (list): The determined a_atoms.</span>
<span class="sd">        n (int): The 0-index of the atom in the zmat to be added.</span>
<span class="sd">        atom_index (int): The 0-index of the atom in the molecule or cartesian coordinates to be added.</span>
<span class="sd">                          (``n`` and ``atom_index`` refer to the same atom, but it might have different indices</span>
<span class="sd">                          in the zmat and the molecule/xyz)</span>
<span class="sd">        d_constraint (tuple, optional): D-type constraints. The atom indices to which the atom being checked is</span>
<span class="sd">                                        constrained. ``None`` if it is not constrained.</span>
<span class="sd">        d_constraint_type (str, optional): The D constraint type (&#39;D_atom&#39;, or &#39;D_group&#39;).</span>
<span class="sd">        specific_atom (int, optional): A 0-index of the zmat atom to be added to a_atoms to create d_atoms.</span>
<span class="sd">        dummy (bool, optional): Whether the atom being added (n) represents a dummy atom. ``True`` if it does.</span>
<span class="sd">        fragments (List[List[int]], optional):</span>
<span class="sd">            Fragments represented by the species, i.e., as in a VdW well or a TS.</span>
<span class="sd">            Entries are atom index lists of all atoms in a fragment, each list represents a different fragment.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If the A atoms could not be determined.</span>
<span class="sd">            indices are 0-indexed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Optional[List[int]]: The 0-indexed z-mat D atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_atom_in_new_fragment</span><span class="p">(</span><span class="n">atom_index</span><span class="o">=</span><span class="n">atom_index</span><span class="p">,</span> <span class="n">zmat</span><span class="o">=</span><span class="n">zmat</span><span class="p">,</span>
                                                       <span class="n">fragments</span><span class="o">=</span><span class="n">fragments</span><span class="p">,</span> <span class="n">skip_atoms</span><span class="o">=</span><span class="n">a_atoms</span><span class="p">):</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">a_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;a_atoms must be a list of length 3, got </span><span class="si">{</span><span class="n">a_atoms</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># This is the 1st, 2nd, or 3rd atom added to the zmat, there&#39;s no dihedral angle definition here.</span>
        <span class="n">d_atoms</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">d_constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">d_constraint_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;D_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;D_group&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Got an invalid D constraint type &quot;</span><span class="si">{</span><span class="n">d_constraint_type</span><span class="si">}</span><span class="s1">&quot; for </span><span class="si">{</span><span class="n">d_constraint</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">d_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">d_constraint</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
    <span class="k">elif</span> <span class="n">specific_atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># A specific atom was specified (e.g., a dummy atom was added to assist defining this atom), consider it.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">specific_atom</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;specific atom must be of type int, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">specific_atom</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">d_atoms</span> <span class="o">=</span> <span class="n">a_atoms</span> <span class="o">+</span> <span class="p">[</span><span class="n">specific_atom</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">connectivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">d_atoms</span> <span class="o">=</span> <span class="n">determine_d_atoms_from_connectivity</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">,</span> <span class="n">a_atoms</span><span class="p">,</span> <span class="n">atom_index</span><span class="p">,</span>
                                                      <span class="n">dummy</span><span class="o">=</span><span class="n">dummy</span><span class="p">,</span> <span class="n">allow_a_to_be_dummy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_atoms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">d_atoms</span> <span class="o">=</span> <span class="n">determine_d_atoms_without_connectivity</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">a_atoms</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_atoms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">d_atoms</span> <span class="o">=</span> <span class="n">determine_d_atoms_from_connectivity</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">,</span> <span class="n">a_atoms</span><span class="p">,</span> <span class="n">atom_index</span><span class="p">,</span>
                                                              <span class="n">dummy</span><span class="o">=</span><span class="n">dummy</span><span class="p">,</span> <span class="n">allow_a_to_be_dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d_atoms</span> <span class="o">=</span> <span class="n">determine_d_atoms_without_connectivity</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">a_atoms</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_atoms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">]))):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_atoms</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">z_index</span><span class="p">]</span>
                                                                  <span class="k">for</span> <span class="n">z_index</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">):</span>
                        <span class="n">d_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">d_atoms</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not come up with four unique d_atoms (d_atoms = </span><span class="si">{</span><span class="n">d_atoms</span><span class="si">}</span><span class="s1">). &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;Setting d_atoms to [</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">, 2, 1, 0]&#39;</span><span class="p">)</span>
            <span class="n">d_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">d_atom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">d_atom</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]):</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A reference D atom in </span><span class="si">{</span><span class="n">d_atoms</span><span class="si">}</span><span class="s1"> for the index atom </span><span class="si">{</span><span class="n">atom_index</span><span class="si">}</span><span class="s1"> has not been &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;added to the zmat yet. Added atoms are (zmat index: xyz index): </span><span class="si">{</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d_atoms</span></div>


<div class="viewcode-block" id="determine_d_atoms_without_connectivity"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.determine_d_atoms_without_connectivity">[docs]</a><span class="k">def</span> <span class="nf">determine_d_atoms_without_connectivity</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                           <span class="n">coords</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                                           <span class="n">a_atoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                                           <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function to determine d_atoms without connectivity information.</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        coords (Union[list, tuple]): Just the &#39;coords&#39; part of the xyz dict.</span>
<span class="sd">        a_atoms (list): The determined a_atoms.</span>
<span class="sd">        n (int): The 0-index of the atom in the zmat to be added.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: The d_atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">a_atoms</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_atoms</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_dummy</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">i</span><span class="p">)):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">z_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">z_index</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">):</span>
                <span class="n">d_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">break</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_atoms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># Try again and consider dummies.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_atoms</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">z_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">z_index</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">):</span>
                    <span class="n">d_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">break</span>
    <span class="k">return</span> <span class="n">d_atoms</span></div>


<div class="viewcode-block" id="determine_d_atoms_from_connectivity"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.determine_d_atoms_from_connectivity">[docs]</a><span class="k">def</span> <span class="nf">determine_d_atoms_from_connectivity</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                        <span class="n">xyz</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                        <span class="n">coords</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                                        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                        <span class="n">a_atoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                                        <span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                        <span class="n">dummy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="n">allow_a_to_be_dummy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function to determine d_atoms from the connectivity information.</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        xyz (dict): The xyz dict.</span>
<span class="sd">        coords (Union[list, tuple]): Just the &#39;coords&#39; part of the xyz dict.</span>
<span class="sd">        connectivity (dict): The atoms connectivity (keys are indices in the mol/xyz).</span>
<span class="sd">        a_atoms (list): The determined a_atoms.</span>
<span class="sd">        atom_index (int): The 0-index of the atom in the molecule or cartesian coordinates to be added.</span>
<span class="sd">                          (``n`` and ``atom_index`` refer to the same atom, but it might have different indices</span>
<span class="sd">                          in the zmat and the molecule/xyz)</span>
<span class="sd">        dummy (bool, optional): Whether the atom being added (n) represents a dummy atom. ``True`` if it does.</span>
<span class="sd">        allow_a_to_be_dummy (bool, optional): Whether the last atom (&#39;A&#39;) in d_atoms is allowed to by a dummy atom.</span>
<span class="sd">                                              ``True`` if it is, ``False`` by default.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: The d_atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">a_atoms</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">d_atoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">+</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">d_atoms</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]]</span> \
            <span class="o">+</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_index</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="o">!=</span> <span class="n">atom_index</span> <span class="ow">and</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_dummy</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">dummy</span> <span class="ow">and</span> <span class="n">allow_a_to_be_dummy</span><span class="p">)):</span>
            <span class="c1"># Atom A is allowed to be a dummy atom only if the atom represented by n is not.</span>
            <span class="n">zmat_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">atom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">([</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">d_atom</span><span class="p">]</span> <span class="k">for</span> <span class="n">d_atom</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]):</span>
                <span class="c1"># Check whether this atom (A) is part of a linear chain. If it is, try to correctly determine</span>
                <span class="c1"># dihedrals in this molecule w/o this atom, otherwise it&#39;s meaningless, and the zmat looses info.</span>
                <span class="c1">#</span>
                <span class="c1">#             X       D (atom_index)</span>
                <span class="c1">#              \     /</span>
                <span class="c1">#    E -- A -- B -- C  (r_atoms[1])</span>
                <span class="c1">#   /</span>
                <span class="c1">#  F     (A is the atom considered here, corresponding to &#39;atom&#39; / &#39;zmat_index&#39;)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">atom_a</span><span class="p">,</span> <span class="n">atom_b</span><span class="p">,</span> <span class="n">atom_c</span> <span class="o">=</span> <span class="n">atom</span><span class="p">,</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">connectivity</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                    <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">atom_a</span><span class="p">,</span> <span class="n">atom_b</span><span class="p">,</span> <span class="n">atom_c</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">):</span>
                        <span class="n">num_of_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">connectivity</span><span class="p">[</span><span class="n">atom_a</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="n">num_of_neighbors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># Atom A is only connected to B, use the dummy atom on atom B as atom A.</span>
                            <span class="n">b_neighbors</span> <span class="o">=</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_b</span><span class="p">]</span>
                            <span class="n">x_neighbor</span> <span class="o">=</span> <span class="p">[</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">b_neighbors</span>
                                          <span class="k">if</span> <span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s1">&#39;X</span><span class="si">{</span><span class="n">x_neighbor</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">:</span>
                                <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s1">&#39;X</span><span class="si">{</span><span class="n">x_neighbor</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                                <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">num_of_neighbors</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="c1"># atom A is only connected to B and E, check the E -- B -- C angle.</span>
                            <span class="n">a_neighbors</span> <span class="o">=</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_a</span><span class="p">]</span>
                            <span class="n">atom_e</span> <span class="o">=</span> <span class="n">a_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">a_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">atom_b</span> <span class="k">else</span> <span class="n">a_neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">atom_e</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                                <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">atom_e</span><span class="p">,</span> <span class="n">atom_b</span><span class="p">,</span> <span class="n">atom_c</span><span class="p">])</span>
                                <span class="k">if</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">):</span>
                                    <span class="c1"># E -- B -- C is linear, change indices and test angle F -- B -- C.</span>
                                    <span class="n">atom_a</span> <span class="o">=</span> <span class="n">atom_e</span>
                                <span class="k">elif</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom_e</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">:</span>
                                    <span class="c1"># E -- B -- C is not linear, use atom E.</span>
                                    <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom_e</span><span class="p">)</span>
                                    <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">num_of_neighbors</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="c1"># Atom A is connected to at least one other atom not in this linear chain.</span>
                            <span class="k">for</span> <span class="n">a_neighbor</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_a</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">a_neighbor</span> <span class="o">!=</span> <span class="n">atom_b</span><span class="p">:</span>
                                    <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">a_neighbor</span><span class="p">,</span> <span class="n">atom_b</span><span class="p">,</span> <span class="n">atom_c</span><span class="p">])</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">)</span> \
                                            <span class="ow">and</span> <span class="n">a_neighbor</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> \
                                            <span class="ow">and</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">a_neighbor</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">:</span>
                                        <span class="c1"># E -- B -- C is not linear, use atom E (a_neighbor).</span>
                                        <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">a_neighbor</span><span class="p">)</span>
                                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">atom_a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                        <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">atom_a</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Don&#39;t loop forever.</span>
            <span class="k">if</span> <span class="n">zmat_index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="s1">&#39;X&#39;</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">]</span> \
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">dummy</span> <span class="ow">and</span> <span class="n">allow_a_to_be_dummy</span><span class="p">:</span>
                <span class="c1"># Still could not find a non-linear forth d atom, look for dummy atoms.</span>
                <span class="n">dummies</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;X\d&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">))]</span>
                <span class="k">for</span> <span class="n">dummy</span> <span class="ow">in</span> <span class="n">dummies</span><span class="p">:</span>
                    <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">zmat_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">d_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zmat_index</span><span class="p">)</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">connectivity</span><span class="p">[</span><span class="n">atom_index</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span> \
            <span class="ow">and</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> \
            <span class="ow">and</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">d_atom</span><span class="p">]</span> <span class="k">for</span> <span class="n">d_atom</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">d_atom</span><span class="p">]</span> <span class="k">for</span> <span class="n">d_atom</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
                                                     <span class="o">+</span> <span class="p">[</span><span class="n">connectivity</span><span class="p">[</span><span class="n">atom_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> \
                <span class="ow">and</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_index</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">:</span>
            <span class="n">d_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">atom_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">d_atoms</span></div>


<span class="k">def</span> <span class="nf">_add_nth_atom_to_zmat</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]],</span>
                          <span class="n">xyz</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                          <span class="n">connectivity</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                          <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                          <span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                          <span class="n">constraints</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
                          <span class="n">fragments</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add the n-th atom to the zmat (n &gt;= 0).</span>
<span class="sd">    Also considers the special cases where ``n`` is the first, second, or third atom to be added to the zmat.</span>
<span class="sd">    Adds a dummy atom if an angle (not a dihedral angle) is 180 (or 0) degrees.</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        xyz (dict): The coordinates.</span>
<span class="sd">        connectivity (dict): The atoms connectivity (keys are indices in the mol/xyz).</span>
<span class="sd">        n (int): The 0-index of the atom in the zmat to be added.</span>
<span class="sd">        atom_index (int): The 0-index of the atom in the molecule or cartesian coordinates to be added.</span>
<span class="sd">                          (``n`` and ``atom_index`` refer to the same atom, but it might have different indices</span>
<span class="sd">                          in the zmat and the molecule/xyz)</span>
<span class="sd">        constraints (dict): Constraints to consider.</span>
<span class="sd">                            Accepted keys are:</span>
<span class="sd">                           &#39;R_atom&#39;, &#39;R_group&#39;,</span>
<span class="sd">                           &#39;A_atom&#39;, &#39;A_group&#39;,</span>
<span class="sd">                           &#39;D_atom&#39;, &#39;D_group&#39;.</span>
<span class="sd">        fragments (List[List[int]]):</span>
<span class="sd">            Fragments represented by the species, i.e., as in a VdW well or a TS.</span>
<span class="sd">            Entries are atom index lists of all atoms in a fragment, each list represents a different fragment.</span>
<span class="sd">            indices are 0-indexed.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If the zmat could not be generated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[Dict[str, tuple], Dict[str, tuple], List[int]]:</span>
<span class="sd">          - The updated zmat.</span>
<span class="sd">          - The xyz coordinates updated with dummy atoms.</span>
<span class="sd">          - A 0- or 1-length list with the skipped atom index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span>
    <span class="n">skipped_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">specific_last_d_atom</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">r_constraint</span><span class="p">,</span> <span class="n">r_constraint_type</span> <span class="o">=</span> <span class="n">check_atom_r_constraints</span><span class="p">(</span><span class="n">atom_index</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
    <span class="n">a_constraint</span><span class="p">,</span> <span class="n">a_constraint_type</span> <span class="o">=</span> <span class="n">check_atom_a_constraints</span><span class="p">(</span><span class="n">atom_index</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
    <span class="n">d_constraint</span><span class="p">,</span> <span class="n">d_constraint_type</span> <span class="o">=</span> <span class="n">check_atom_d_constraints</span><span class="p">(</span><span class="n">atom_index</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="n">constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="p">[</span><span class="n">r_constraint</span><span class="p">,</span> <span class="n">a_constraint</span><span class="p">,</span> <span class="n">d_constraint</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A single atom cannot be constrained by more than one constraint type, got:</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;R </span><span class="si">{</span><span class="n">r_constraint_type</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">r_constraint</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;A </span><span class="si">{</span><span class="n">a_constraint_type</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">a_constraint</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;D </span><span class="si">{</span><span class="n">d_constraint_type</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">d_constraint</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">r_constraints_passed</span><span class="p">,</span> <span class="n">a_constraints_passed</span><span class="p">,</span> <span class="n">d_constraints_passed</span> <span class="o">=</span> \
        <span class="p">[</span><span class="n">constraint</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">([</span><span class="n">entry</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">constraint</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
         <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="p">[</span><span class="n">r_constraint</span><span class="p">,</span> <span class="n">a_constraint</span><span class="p">,</span> <span class="n">d_constraint</span><span class="p">]]</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">passed</span> <span class="k">for</span> <span class="n">passed</span> <span class="ow">in</span> <span class="p">[</span><span class="n">r_constraints_passed</span><span class="p">,</span> <span class="n">a_constraints_passed</span><span class="p">,</span> <span class="n">d_constraints_passed</span><span class="p">]]):</span>
        <span class="c1"># Add the n-th atom to the zmat.</span>

        <span class="c1"># If an &#39;_atom&#39; constraint was specified, only consider this atom if n is the last atom to consider.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r_constraint_type</span> <span class="o">==</span> <span class="s1">&#39;R_atom&#39;</span> <span class="ow">or</span> <span class="n">a_constraint_type</span> <span class="o">==</span> <span class="s1">&#39;A_atom&#39;</span> <span class="ow">or</span> <span class="n">d_constraint_type</span> <span class="o">==</span> <span class="s1">&#39;D_atom&#39;</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">([</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;X&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">symbol</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Skipping atom index </span><span class="si">{</span><span class="n">atom_index</span><span class="si">}</span><span class="s1"> when creating a zmat due to a specified _atom constraint.&#39;</span><span class="p">)</span>
            <span class="n">skipped_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_index</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">zmat</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">skipped_atoms</span>

        <span class="c1"># Determine the atoms for defining the distance, R; this should be [n, &lt;some other atom already in the zmat&gt;].</span>
        <span class="n">r_atoms</span> <span class="o">=</span> <span class="n">determine_r_atoms</span><span class="p">(</span>
            <span class="n">zmat</span><span class="p">,</span>
            <span class="n">xyz</span><span class="p">,</span>
            <span class="n">connectivity</span><span class="p">,</span>
            <span class="n">n</span><span class="p">,</span>
            <span class="n">atom_index</span><span class="p">,</span>
            <span class="n">r_constraint</span><span class="p">,</span>
            <span class="n">a_constraint</span><span class="p">,</span>
            <span class="n">d_constraint</span><span class="p">,</span>
            <span class="n">trivial_assignment</span><span class="o">=</span><span class="nb">any</span><span class="p">(</span><span class="s1">&#39;_atom&#39;</span> <span class="ow">in</span> <span class="n">constraint_key</span> <span class="k">for</span> <span class="n">constraint_key</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="n">fragments</span><span class="o">=</span><span class="n">fragments</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Determine the atoms for defining the angle, A.</span>
        <span class="k">if</span> <span class="n">a_constraint</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">d_constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If a D constraint is given, the A constraint must obey it as well.</span>
            <span class="n">a_constraint</span> <span class="o">=</span> <span class="n">d_constraint</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">a_atoms</span> <span class="o">=</span> <span class="n">determine_a_atoms</span><span class="p">(</span>
            <span class="n">zmat</span><span class="p">,</span>
            <span class="n">coords</span><span class="p">,</span>
            <span class="n">connectivity</span><span class="p">,</span>
            <span class="n">r_atoms</span><span class="p">,</span>
            <span class="n">n</span><span class="p">,</span>
            <span class="n">atom_index</span><span class="p">,</span>
            <span class="n">a_constraint</span><span class="p">,</span>
            <span class="n">d_constraint</span><span class="p">,</span>
            <span class="n">a_constraint_type</span><span class="p">,</span>
            <span class="n">trivial_assignment</span><span class="o">=</span><span class="nb">any</span><span class="p">(</span><span class="s1">&#39;_atom&#39;</span> <span class="ow">in</span> <span class="n">constraint_key</span> <span class="k">for</span> <span class="n">constraint_key</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="n">fragments</span><span class="o">=</span><span class="n">fragments</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Calculate the angle, add a dummy atom if needed.</span>
        <span class="n">added_dummy</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">a_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;X\d&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">atom</span><span class="p">]))</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">a_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">atom_index</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">atom</span><span class="p">]</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">a_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
            <span class="k">if</span> <span class="n">is_angle_linear</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">TOL_180</span><span class="p">):</span>
                <span class="c1"># The angle is too close to 180 (or 0) degrees, add a dummy atom.</span>
                <span class="n">zmat</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r_atoms</span><span class="p">,</span> <span class="n">a_atoms</span><span class="p">,</span> <span class="n">specific_last_d_atom</span> <span class="o">=</span> \
                    <span class="n">add_dummy_atom</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">,</span> <span class="n">r_atoms</span><span class="p">,</span> <span class="n">a_atoms</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">atom_index</span><span class="p">)</span>
                <span class="n">added_dummy</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Determine the atoms for defining the dihedral angle, D.</span>
        <span class="n">d_atoms</span> <span class="o">=</span> <span class="n">determine_d_atoms</span><span class="p">(</span>
            <span class="n">zmat</span><span class="p">,</span>
            <span class="n">xyz</span><span class="p">,</span>
            <span class="n">coords</span><span class="p">,</span>
            <span class="n">connectivity</span><span class="p">,</span>
            <span class="n">a_atoms</span><span class="p">,</span>
            <span class="n">n</span><span class="p">,</span>
            <span class="n">atom_index</span><span class="p">,</span>
            <span class="n">d_constraint</span><span class="p">,</span>
            <span class="n">d_constraint_type</span><span class="p">,</span> <span class="n">specific_atom</span><span class="o">=</span><span class="n">specific_last_d_atom</span><span class="p">,</span>
            <span class="n">fragments</span><span class="o">=</span><span class="n">fragments</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update the zmat.</span>
        <span class="n">zmat</span> <span class="o">=</span> <span class="n">update_zmat_with_new_atom</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">atom_index</span><span class="p">,</span> <span class="n">r_atoms</span><span class="p">,</span> <span class="n">a_atoms</span><span class="p">,</span> <span class="n">d_atoms</span><span class="p">,</span> <span class="n">added_dummy</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Some constraints did not &quot;pass&quot;: some atoms were not added to the zmat yet; skip this atom until they are.</span>
        <span class="n">skipped_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_index</span><span class="p">)</span>

    <span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span>  <span class="c1"># Update xyz with the updated coords.</span>
    <span class="k">return</span> <span class="n">zmat</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">skipped_atoms</span>


<div class="viewcode-block" id="update_zmat_with_new_atom"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.update_zmat_with_new_atom">[docs]</a><span class="k">def</span> <span class="nf">update_zmat_with_new_atom</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                              <span class="n">xyz</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                              <span class="n">coords</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                              <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                              <span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                              <span class="n">r_atoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                              <span class="n">a_atoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                              <span class="n">d_atoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                              <span class="n">added_dummy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Update the zmat with a new atom.</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        xyz (dict): The xyz dict.</span>
<span class="sd">        coords (Union[list, tuple]): Just the &#39;coords&#39; part of the xyz dict.</span>
<span class="sd">        n (int): The 0-index of the atom in the zmat to be added.</span>
<span class="sd">        atom_index (int): The 0-index of the atom in the molecule or cartesian coordinates to be added.</span>
<span class="sd">                          (``n`` and ``atom_index`` refer to the same atom, but it might have different indices</span>
<span class="sd">                          in the zmat and the molecule/xyz)</span>
<span class="sd">        r_atoms (list): The R atom index descriptors.</span>
<span class="sd">        a_atoms (list): The A atom index descriptors.</span>
<span class="sd">        d_atoms (list): The D atom index descriptors.</span>
<span class="sd">        added_dummy (bool, optional): Whether a dummy atom was added as the last index of a_atoms.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: The updated zmat.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">atom_index</span><span class="p">])</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_index</span>
    <span class="k">if</span> <span class="n">r_atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">r_str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span> <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;X&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">([</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">atom</span><span class="p">]])</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">r_atoms</span><span class="p">])</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">r_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;R</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">r_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">r_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">if</span> <span class="n">a_atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">a_str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span> <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;X&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">([</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">atom</span><span class="p">]])</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">a_atoms</span><span class="p">])</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">a_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;A</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">a_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">a_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">a_atoms</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">if</span> <span class="n">d_atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">d_str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span> <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;X&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">([</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">atom</span><span class="p">]])</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">])</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">d_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;D</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="p">[</span><span class="n">r_str</span><span class="p">,</span> <span class="n">a_str</span><span class="p">,</span> <span class="n">d_str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">string</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">string</span><span class="si">}</span><span class="s1"> is already in vars: </span><span class="si">{</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;vars&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r_str</span><span class="p">,</span> <span class="n">a_str</span><span class="p">,</span> <span class="n">d_str</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">atoms</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="p">[</span><span class="n">r_atoms</span><span class="p">,</span> <span class="n">a_atoms</span><span class="p">,</span> <span class="n">d_atoms</span><span class="p">]]):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmat atom specifications must not have repetitions, got:</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;r_atoms = </span><span class="si">{</span><span class="n">r_atoms</span><span class="si">}</span><span class="s1">, a_atoms = </span><span class="si">{</span><span class="n">a_atoms</span><span class="si">}</span><span class="s1">, d_atoms =</span><span class="si">{</span><span class="n">d_atoms</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">r_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">atom</span><span class="p">]</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">r_atoms</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">added_dummy</span><span class="p">:</span>
        <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">a_str</span><span class="p">]</span> <span class="o">=</span> <span class="mf">90.0</span>
        <span class="c1"># The dihedral angle could be either 0 or 180 degrees, depends on the relative position of atom D and B, C</span>
        <span class="c1"># d_atoms represent the zmat indices of atoms D, C, X, and B.</span>
        <span class="n">bcd_angle</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                          <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">180</span> <span class="o">-</span> <span class="n">TOL_180</span> <span class="o">&lt;</span> <span class="n">bcd_angle</span> <span class="o">&lt;=</span> <span class="mi">180</span><span class="p">:</span>
            <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">d_str</span><span class="p">]</span> <span class="o">=</span> <span class="mf">180.0</span>
        <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">bcd_angle</span> <span class="o">&lt;</span> <span class="n">TOL_180</span><span class="p">:</span>
            <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">d_str</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Atoms </span><span class="si">{</span><span class="n">d_atoms</span><span class="si">}</span><span class="s1"> for a non-linear sequence with an angle of </span><span class="si">{</span><span class="n">bcd_angle</span><span class="si">}</span><span class="s1">. &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;Expected a linear sequence when using a dummy atom.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">a_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">atom</span><span class="p">]</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">a_atoms</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">d_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">d_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">atom</span><span class="p">]</span>
                                                                        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">d_atoms</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">zmat</span></div>


<div class="viewcode-block" id="add_dummy_atom"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.add_dummy_atom">[docs]</a><span class="k">def</span> <span class="nf">add_dummy_atom</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                   <span class="n">xyz</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                   <span class="n">coords</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                   <span class="n">connectivity</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                   <span class="n">r_atoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                   <span class="n">a_atoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                   <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                   <span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a dummy atom &#39;X&#39; to the zmat.</span>
<span class="sd">    Also updates the r_atoms and a_atoms lists for the original (non-dummy) atom.</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        xyz (dict): The xyz dict.</span>
<span class="sd">        coords (Union[list, tuple]): Just the &#39;coords&#39; part of the xyz dict.</span>
<span class="sd">        connectivity (dict): The atoms connectivity (keys are indices in the mol/xyz).</span>
<span class="sd">        r_atoms (list): The determined r_atoms.</span>
<span class="sd">        a_atoms (list): The determined a_atoms.</span>
<span class="sd">        n (int): The 0-index of the atom in the zmat to be added.</span>
<span class="sd">        atom_index (int): The 0-index of the atom in the molecule or cartesian coordinates to be added.</span>
<span class="sd">                          (``n`` and ``atom_index`` refer to the same atom, but it might have different indices</span>
<span class="sd">                          in the zmat and the molecule/xyz)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[dict, list, int, list, list, int]:</span>
<span class="sd">            - The zmat.</span>
<span class="sd">            - The coordinates (list of tuples).</span>
<span class="sd">            - The updated atom index in the zmat.</span>
<span class="sd">            - The R atom indices.</span>
<span class="sd">            - The A atom indices.</span>
<span class="sd">            - A specific atom index to be used as the last entry of the D atom indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;X</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,)</span>
    <span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;isotopes&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;None&#39;</span><span class="p">,)</span>

    <span class="c1"># Determine the atoms for defining the dihedral angle, D, **for the dummy atom, X**.</span>
    <span class="n">d_atoms</span> <span class="o">=</span> <span class="n">determine_d_atoms</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">,</span> <span class="n">a_atoms</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">atom_index</span><span class="p">,</span> <span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">r_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;RX_</span><span class="si">{</span><span class="n">r_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">r_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">a_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;AX_</span><span class="si">{</span><span class="n">a_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">a_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">a_atoms</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">d_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;DX_</span><span class="si">{</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">d_atoms</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">d_atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r_str</span><span class="p">,</span> <span class="n">a_str</span><span class="p">,</span> <span class="n">d_str</span><span class="p">))</span>  <span class="c1"># the coords of the dummy atom</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">r_str</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">a_str</span><span class="p">]</span> <span class="o">=</span> <span class="mf">90.0</span>
    <span class="k">if</span> <span class="n">d_str</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">d_str</span><span class="p">]</span> <span class="o">=</span> <span class="mi">180</span>
    <span class="c1"># Update xyz with the dummy atom (useful when this atom is used to define dihedrals of other atoms).</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">_add_nth_atom_to_coords</span><span class="p">(</span><span class="n">zmat</span><span class="o">=</span><span class="n">zmat</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">connectivity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Update the connectivity dict to reflect that X is connected to the respective atom (r_atoms[1]),</span>
        <span class="c1"># this will help later in avoiding linear angles in the last three indices of a dihedral.</span>
        <span class="n">connectivity</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">r_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">:]))</span>  <span class="c1"># Take from &#39;X15&#39;.</span>
        <span class="n">connectivity</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span> <span class="o">=</span> <span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">r_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
    <span class="c1"># Before adding the original (non-dummy) atom, increase n due to the increased number of atoms.</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Store atom B&#39;s index for the dihedral of atom D.</span>
    <span class="n">specific_last_d_atom</span> <span class="o">=</span> <span class="n">a_atoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Update the r_atoms and a_atoms for the original (non-dummy) atom (d_atoms is set below).</span>
    <span class="c1">#</span>
    <span class="c1">#          X (dummy atom)</span>
    <span class="c1">#          |</span>
    <span class="c1">#     B -- C -- D (original atom)</span>
    <span class="c1">#   /</span>
    <span class="c1">#  A (optional)</span>
    <span class="n">r_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">r_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># make this (D, C)</span>
    <span class="n">a_atoms</span> <span class="o">=</span> <span class="n">r_atoms</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># make this (D, C, X)</span>
    <span class="k">return</span> <span class="n">zmat</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r_atoms</span><span class="p">,</span> <span class="n">a_atoms</span><span class="p">,</span> <span class="n">specific_last_d_atom</span></div>


<div class="viewcode-block" id="zmat_to_coords"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.zmat_to_coords">[docs]</a><span class="k">def</span> <span class="nf">zmat_to_coords</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                   <span class="n">keep_dummy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">skip_undefined</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the cartesian coordinates from a zmat dict.</span>
<span class="sd">    Considers the zmat atomic map so the returned coordinates is ordered correctly.</span>
<span class="sd">    Most common isotopes assumed, if this is not the case, then isotopes should be reassigned to the xyz.</span>
<span class="sd">    This function assumes that all zmat variables relate to already defined atoms with a lower index in the zmat.</span>

<span class="sd">    This function implements the SN-NeRF algorithm as described in:</span>
<span class="sd">    J. Parsons, J.B. Holmes, J.M Rojas, J. Tsai, C.E.M. Strauss, &quot;Practical Conversion from Torsion Space to Cartesian</span>
<span class="sd">    Space for In Silico Protein Synthesis&quot;, Journal of Computational Chemistry 2005, 26 (10), 1063-1068,</span>
<span class="sd">    https://doi.org/10.1002/jcc.20237</span>

<span class="sd">    Tested in converterTest.py rather than zmatTest</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        keep_dummy (bool): Whether to keep dummy atoms (&#39;X&#39;), ``True`` to keep, default is ``False``.</span>
<span class="sd">        skip_undefined (bool): Whether to skip atoms with undefined variables, instead of raising an error.</span>
<span class="sd">                               ``True`` to skip, default is ``False``.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If zmat is of wrong type or does not contain all keys.</span>

<span class="sd">    Returns: Tuple[List[dict], List[str]]</span>
<span class="sd">        - The cartesian coordinates.</span>
<span class="sd">        - The atomic symbols corresponding to the coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmat has to be a dictionary, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">zmat</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;symbols&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat</span> <span class="ow">or</span> <span class="s1">&#39;coords&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat</span> <span class="ow">or</span> <span class="s1">&#39;vars&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat</span> <span class="ow">or</span> <span class="s1">&#39;map&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Expected to find symbols, coords, vars, and map in zmat, got instead: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmat sections symbols, coords, and map have different lengths: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">, &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">, and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">, respectively.&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Got ``None`` for var </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1"> in zmat:</span><span class="se">\n</span><span class="si">{</span><span class="n">zmat</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">var_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">coords_to_skip</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">skip_undefined</span><span class="p">:</span>
                    <span class="n">coords_to_skip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The parameter </span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s1"> was not found in the &quot;vars&quot; section of &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;the zmat:</span><span class="se">\n</span><span class="si">{</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;vars&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">_add_nth_atom_to_coords</span><span class="p">(</span><span class="n">zmat</span><span class="o">=</span><span class="n">zmat</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">coords_to_skip</span><span class="o">=</span><span class="n">coords_to_skip</span><span class="p">)</span>

    <span class="c1"># Reorder the xyz according to the zmat map and remove dummy atoms if requested.</span>
    <span class="n">ordered_coords</span><span class="p">,</span> <span class="n">ordered_symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])):</span>
        <span class="n">zmat_index</span> <span class="o">=</span> <span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zmat_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coords_to_skip</span> <span class="ow">and</span> <span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">zmat_index</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;X&#39;</span> <span class="ow">or</span> <span class="n">keep_dummy</span><span class="p">):</span>
            <span class="n">ordered_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">zmat_index</span><span class="p">])</span>
            <span class="n">ordered_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">zmat_index</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ordered_coords</span><span class="p">,</span> <span class="n">ordered_symbols</span></div>


<span class="k">def</span> <span class="nf">_add_nth_atom_to_coords</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                            <span class="n">coords</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                            <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                            <span class="n">coords_to_skip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add the n-th atom to the coords (n &gt;= 0).</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        coords (list): The coordinates to be updated (not the entire xyz dict).</span>
<span class="sd">        i (int): The atom number in the zmat to be added to the coords (0-indexed)</span>
<span class="sd">        coords_to_skip (list, optional): Entries are indices to skip.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: The updated coords.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords_to_skip</span> <span class="o">=</span> <span class="n">coords_to_skip</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Add the 1st atom.</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>  <span class="c1"># atom A is placed at the origin</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Add the 2nd atom.</span>
        <span class="n">r_key</span> <span class="o">=</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">r_key</span><span class="p">]))</span>  <span class="c1"># atom B is placed on axis Z, distant by the AB bond length</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Add the 3rd atom (atom &quot;C&quot;).</span>
        <span class="n">r_key</span><span class="p">,</span> <span class="n">a_key</span> <span class="o">=</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bc_length</span> <span class="o">=</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">r_key</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">a_key</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">alpha</span> <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">180</span> <span class="k">else</span> <span class="mi">360</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">b_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span> <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">get_atom_indices_from_zmat_parameter</span><span class="p">(</span><span class="n">r_key</span><span class="p">)</span> <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">b_z</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">b_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">c_y</span> <span class="o">=</span> <span class="n">bc_length</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="c1"># We differentiate between two cases for c_z:</span>
        <span class="c1"># Either atom A is at the origin (case 1), or atom B is at the origin (case 2).</span>
        <span class="c1"># One of them has to be at the origin (0, 0, 0), since we&#39;re adding the 3rd atom (so either A or B were 1st).</span>
        <span class="c1">#</span>
        <span class="c1">#  y</span>
        <span class="c1">#  ^                    C                         C</span>
        <span class="c1">#  |           (1)       \        or     (2)     /</span>
        <span class="c1">#  L__ &gt; z           A -- B                    B -- A</span>
        <span class="c1">#</span>
        <span class="c1"># In case 1, we need to deduct len(B-C) from the z coordinate of atom B,</span>
        <span class="c1"># but in case 2 we need to take the positive value of len(B-C).</span>
        <span class="c1"># The above is also true if alpha(A-B-C) is &gt; 90 degrees.</span>
        <span class="n">c_z</span> <span class="o">=</span> <span class="n">b_z</span> <span class="o">-</span> <span class="n">bc_length</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="k">if</span> <span class="n">b_z</span> <span class="k">else</span> <span class="n">bc_length</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">c_y</span><span class="p">,</span> <span class="n">c_z</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coords_to_skip</span><span class="p">:</span>
        <span class="n">d_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span> <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">get_atom_indices_from_zmat_parameter</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                     <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a_index</span><span class="p">,</span> <span class="n">b_index</span><span class="p">,</span> <span class="n">c_index</span> <span class="o">=</span> <span class="n">d_indices</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d_indices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">d_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Atoms B and C aren&#39;t necessarily connected in the zmat, calculate from coords.</span>
        <span class="n">bc_length</span> <span class="o">=</span> <span class="n">get_vector_length</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">c_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">b_index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                       <span class="n">coords</span><span class="p">[</span><span class="n">c_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">b_index</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="n">coords</span><span class="p">[</span><span class="n">c_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">b_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
        <span class="n">cd_length</span> <span class="o">=</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">bcd_angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">abcd_dihedral</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
        <span class="c1"># A vector pointing from atom A to atom B:</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="p">[(</span><span class="n">coords</span><span class="p">[</span><span class="n">b_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">a_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span>
              <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">b_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">a_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span>
              <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">b_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">a_index</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span>
        <span class="c1"># A normalized vector pointing from atom B to atom C:</span>
        <span class="n">ubc</span> <span class="o">=</span> <span class="p">[(</span><span class="n">coords</span><span class="p">[</span><span class="n">c_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">b_index</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">bc_length</span><span class="p">,</span>
               <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">c_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">b_index</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">bc_length</span><span class="p">,</span>
               <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">c_index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">b_index</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">bc_length</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">ubc</span><span class="p">)</span>
        <span class="n">un</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">get_vector_length</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">un_cross_ubc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="n">ubc</span><span class="p">)</span>

        <span class="c1"># The transformation matrix:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">ubc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">un_cross_ubc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">un</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                      <span class="p">[</span><span class="n">ubc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">un_cross_ubc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">un</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                      <span class="p">[</span><span class="n">ubc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">un_cross_ubc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">un</span><span class="p">[</span><span class="mi">2</span><span class="p">]]],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Place atom D in a default coordinate system.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span> <span class="n">cd_length</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">bcd_angle</span><span class="p">),</span>
                      <span class="n">cd_length</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">bcd_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">abcd_dihedral</span><span class="p">),</span>
                      <span class="n">cd_length</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">bcd_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">abcd_dihedral</span><span class="p">)])</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># Rotate the coordinate system into the reference frame of orientation defined by A, B, C.</span>
        <span class="c1"># Add the coordinates of atom C to the resulting atom D:</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">coords</span><span class="p">[</span><span class="n">c_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coords</span><span class="p">[</span><span class="n">c_index</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">coords</span><span class="p">[</span><span class="n">c_index</span><span class="p">][</span><span class="mi">2</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">coords</span>


<div class="viewcode-block" id="check_atom_r_constraints"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.check_atom_r_constraints">[docs]</a><span class="k">def</span> <span class="nf">check_atom_r_constraints</span><span class="p">(</span><span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                             <span class="n">constraints</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check distance constraints for an atom.</span>
<span class="sd">    &#39;R&#39; constraints are a list of tuples with length 2.</span>
<span class="sd">    The first atom in an R constraint is considered &quot;constraint&quot; for zmat generation:</span>
<span class="sd">    its distance will be relative to the second atom.</span>

<span class="sd">    Args:</span>
<span class="sd">        atom_index (int): The 0-indexed atom index to check.</span>
<span class="sd">        constraints (dict): The &#39;R&#39;, &#39;A&#39;, &#39;D&#39; constraints dict. Values are lists of constraints.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If the R constraint lengths do not equal two, or if the atom is constrained more than once.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[Optional[tuple], Optional[str]]:</span>
<span class="sd">            - The atom index to which the atom being checked is constrained. ``None`` if it is not constrained.</span>
<span class="sd">            - The constraint type (&#39;R_atom&#39;, or &#39;R_group&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;R&#39;</span> <span class="ow">in</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">r_constraints</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;R&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">r_constraint_list</span> <span class="ow">in</span> <span class="n">r_constraints</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">r_constraint_tuple</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">r_constraint_tuple</span> <span class="ow">in</span> <span class="n">r_constraint_list</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;R&quot; constraints must contain only tuples of length two, got: </span><span class="si">{</span><span class="n">r_constraints</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">r_constraint_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;R_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;R_group&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r_constraint_type</span> <span class="ow">in</span> <span class="n">r_constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;R&quot; constraints must be either &quot;R_atom&quot; or &quot;R_group&quot;, got: </span><span class="si">{</span><span class="n">r_constraints</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">occurrences</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">r_constraint_list</span> <span class="ow">in</span> <span class="n">r_constraints</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">occurrences</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">r_constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">atom_index</span> <span class="k">for</span> <span class="n">r_constraint</span> <span class="ow">in</span> <span class="n">r_constraint_list</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">occurrences</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">occurrences</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A single atom cannot be constrained more than once. Atom </span><span class="si">{</span><span class="n">atom_index</span><span class="si">}</span><span class="s1"> is constrained &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">occurrences</span><span class="si">}</span><span class="s1"> times in &quot;R&quot; constraints.&#39;</span><span class="p">)</span>
    <span class="c1"># At this point there&#39;s only one occurrence of this constraint, find it and report the constraining atom.</span>
    <span class="k">for</span> <span class="n">constraint_type</span><span class="p">,</span> <span class="n">r_constraint_list</span> <span class="ow">in</span> <span class="n">r_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">r_constraint</span> <span class="ow">in</span> <span class="n">r_constraint_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">r_constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">atom_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">r_constraint</span><span class="p">,</span> <span class="n">constraint_type</span></div>


<div class="viewcode-block" id="check_atom_a_constraints"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.check_atom_a_constraints">[docs]</a><span class="k">def</span> <span class="nf">check_atom_a_constraints</span><span class="p">(</span><span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                             <span class="n">constraints</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check angle constraints for an atom.</span>
<span class="sd">    &#39;A&#39; constraints are a list of tuples with length 3.</span>
<span class="sd">    The first atom in an A constraint is considered &quot;constraint&quot; for zmat generation:</span>
<span class="sd">    its angle will be relative to the second and third atoms.</span>

<span class="sd">    Args:</span>
<span class="sd">        atom_index (int): The 0-indexed atom index to check.</span>
<span class="sd">        constraints (dict): The &#39;R&#39;, &#39;A&#39;, &#39;D&#39; constraints dict. Values are lists of constraints.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If the A constraint lengths do not equal three, or if the atom is constrained more than once.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[Optional[tuple], Optional[str]]:</span>
<span class="sd">            - The atom indices to which the atom being checked is constrained. ``None`` if it is not constrained.</span>
<span class="sd">            - The constraint type (&#39;A_atom&#39;, or &#39;A_group&#39;). ``None`` if it is not constrained.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;A&#39;</span> <span class="ow">in</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">a_constraints</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;A&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">a_constraint_list</span> <span class="ow">in</span> <span class="n">a_constraints</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a_constraint_tuple</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">a_constraint_tuple</span> <span class="ow">in</span> <span class="n">a_constraint_list</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;A&quot; constraints must contain only tuples of length three, got: </span><span class="si">{</span><span class="n">a_constraints</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">a_constraint_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;A_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;A_group&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">a_constraint_type</span> <span class="ow">in</span> <span class="n">a_constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;A&quot; constraints must be either &quot;A_atom&quot; or &quot;A_group&quot;, got: </span><span class="si">{</span><span class="n">a_constraints</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">occurrences</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">a_constraint_list</span> <span class="ow">in</span> <span class="n">a_constraints</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">occurrences</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a_constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">atom_index</span> <span class="k">for</span> <span class="n">a_constraint</span> <span class="ow">in</span> <span class="n">a_constraint_list</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">occurrences</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">occurrences</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A single atom cannot be constrained more than once. Atom </span><span class="si">{</span><span class="n">atom_index</span><span class="si">}</span><span class="s1"> is constrained &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">occurrences</span><span class="si">}</span><span class="s1"> times in &quot;A&quot; constraints.&#39;</span><span class="p">)</span>
    <span class="c1"># At this point there&#39;s only one occurrence of this constraint, find it and report the constraining atoms.</span>
    <span class="k">for</span> <span class="n">constraint_type</span><span class="p">,</span> <span class="n">a_constraint_list</span> <span class="ow">in</span> <span class="n">a_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">a_constraint</span> <span class="ow">in</span> <span class="n">a_constraint_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a_constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">atom_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a_constraint</span><span class="p">,</span> <span class="n">constraint_type</span></div>


<div class="viewcode-block" id="check_atom_d_constraints"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.check_atom_d_constraints">[docs]</a><span class="k">def</span> <span class="nf">check_atom_d_constraints</span><span class="p">(</span><span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                             <span class="n">constraints</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check dihedral angle constraints for an atom.</span>
<span class="sd">    &#39;D&#39; constraints are a list of tuples with length 4.</span>
<span class="sd">    The first atom in a D constraint is considered &quot;constraint&quot; for zmat generation:</span>
<span class="sd">    its dihedral angle will be relative to the second, third, and forth atoms.</span>

<span class="sd">    Args:</span>
<span class="sd">        atom_index (int): The 0-indexed atom index to check.</span>
<span class="sd">        constraints (dict): The &#39;R&#39;, &#39;A&#39;, &#39;D&#39; constraints dict. Values are lists of constraints.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If the A constraint lengths do not equal three, or if the atom is constrained more than once.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[Optional[tuple], Optional[str]]:</span>
<span class="sd">            - The atom indices to which the atom being checked is constrained. ``None`` if it is not constrained.</span>
<span class="sd">            - The constraint type (&#39;D_atom&#39;, &#39;D_group&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;D&#39;</span> <span class="ow">in</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">d_constraints</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;D&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">d_constraint_list</span> <span class="ow">in</span> <span class="n">d_constraints</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">d_constraint_tuple</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span> <span class="k">for</span> <span class="n">d_constraint_tuple</span> <span class="ow">in</span> <span class="n">d_constraint_list</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;D&quot; constraints must contain only tuples of length four, got: </span><span class="si">{</span><span class="n">d_constraints</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">d_constraint_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;D_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;D_group&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d_constraint_type</span> <span class="ow">in</span> <span class="n">d_constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;D&quot; constraints must be either &quot;D_atom&quot;, or &quot;D_group&quot;, got: </span><span class="si">{</span><span class="n">d_constraints</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">occurrences</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d_constraint_list</span> <span class="ow">in</span> <span class="n">d_constraints</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">occurrences</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d_constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">atom_index</span> <span class="k">for</span> <span class="n">d_constraint</span> <span class="ow">in</span> <span class="n">d_constraint_list</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">occurrences</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">occurrences</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;A single atom cannot be constrained more than once. Atom </span><span class="si">{</span><span class="n">atom_index</span><span class="si">}</span><span class="s1"> is constrained &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">occurrences</span><span class="si">}</span><span class="s1"> times in &quot;D&quot; constraints.&#39;</span><span class="p">)</span>
    <span class="c1"># At this point there&#39;s only one occurrence of this constraint, find it and report the constraining atoms.</span>
    <span class="k">for</span> <span class="n">constraint_type</span><span class="p">,</span> <span class="n">d_constraint_list</span> <span class="ow">in</span> <span class="n">d_constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">d_constraint</span> <span class="ow">in</span> <span class="n">d_constraint_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d_constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">atom_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">d_constraint</span><span class="p">,</span> <span class="n">constraint_type</span></div>


<div class="viewcode-block" id="is_dummy"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.is_dummy">[docs]</a><span class="k">def</span> <span class="nf">is_dummy</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
             <span class="n">zmat_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
             <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether an atom in a zmat is a dummy atom by its zmat index.</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat with symbol and map information.</span>
<span class="sd">        zmat_index (int): The atom index in the zmat.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If the index is invalid.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: Whether the atom represents a dummy atom &#39;X&#39;. ``True`` if it does.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">zmat_index</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;index </span><span class="si">{</span><span class="n">zmat_index</span><span class="si">}</span><span class="s1"> is invalid for a zmat with only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> atoms&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">zmat_index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span></div>


<div class="viewcode-block" id="get_atom_connectivity_from_mol"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.get_atom_connectivity_from_mol">[docs]</a><span class="k">def</span> <span class="nf">get_atom_connectivity_from_mol</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">Molecule</span><span class="p">,</span>
                                   <span class="n">atom1</span><span class="p">:</span> <span class="s1">&#39;Atom&#39;</span><span class="p">,</span>
                                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the connectivity of ``atom`` in ``mol``.</span>
<span class="sd">    Returns heavy (non-H) atoms first.</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): The molecule with connectivity information.</span>
<span class="sd">        atom1 (Atom): The atom to check connectivity for.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[int]: 0-indices of atoms in ``mol`` connected to ``atom``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="n">atom2</span><span class="o">.</span><span class="n">is_non_hydrogen</span><span class="p">()]</span> \
        <span class="o">+</span> <span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="n">atom2</span><span class="o">.</span><span class="n">is_hydrogen</span><span class="p">()]</span></div>


<div class="viewcode-block" id="get_connectivity"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.get_connectivity">[docs]</a><span class="k">def</span> <span class="nf">get_connectivity</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">Molecule</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the connectivity information from the molecule object.</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): The Molecule object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict[int, List[int]]: The connectivity information.</span>
<span class="sd">              Keys are atom indices, values are tuples of respective edges, ordered with heavy atoms first.</span>
<span class="sd">              All indices are 0-indexed, corresponding to atom indices in ``mol`` (not in the zmat).</span>
<span class="sd">              ``None`` if ``xyz`` is given.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">connectivity</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
        <span class="n">connectivity</span><span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)]</span> <span class="o">=</span> <span class="n">get_atom_connectivity_from_mol</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">atom</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">connectivity</span></div>


<div class="viewcode-block" id="order_fragments_by_constraints"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.order_fragments_by_constraints">[docs]</a><span class="k">def</span> <span class="nf">order_fragments_by_constraints</span><span class="p">(</span><span class="n">fragments</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                                   <span class="n">constraints_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the order in which atoms should be added to the zmat from a 2D or a 3D representation.</span>

<span class="sd">    Args:</span>
<span class="sd">        fragments (List[List[int]]):</span>
<span class="sd">            Fragments represented by the species, i.e., as in a VdW well or a TS.</span>
<span class="sd">            Entries are atom index lists of all atoms in a fragment, each list represents a different fragment.</span>
<span class="sd">        constraints_dict (dict, optional):</span>
<span class="sd">            A dictionary of atom constraints. The function will try to find an atom order in which all constrained atoms</span>
<span class="sd">            are after the atoms they are constraint to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[List[int]]: The ordered fragments list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">constraints_dict</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragments</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fragments</span>
    <span class="n">constraints_in_fragments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fragments</span><span class="p">)):</span>
        <span class="c1"># Initialize with general constraint types and the original index.</span>
        <span class="n">constraints_in_fragments</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>
    <span class="k">for</span> <span class="n">constraint_type</span><span class="p">,</span> <span class="n">constraint_list</span> <span class="ow">in</span> <span class="n">constraints_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraint_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fragments</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">c</span> <span class="ow">in</span> <span class="n">fragment</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constraint</span><span class="p">]):</span>
                    <span class="n">constraints_in_fragments</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">constraint_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">constraints_in_fragments</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">new_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">constraint</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraints_in_fragments</span><span class="p">]</span>
    <span class="n">new_fragments</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragments</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fragments</span><span class="p">,</span> <span class="n">new_order</span><span class="p">):</span>
        <span class="n">new_fragments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fragment</span>
    <span class="k">return</span> <span class="n">new_fragments</span></div>


<div class="viewcode-block" id="get_atom_order"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.get_atom_order">[docs]</a><span class="k">def</span> <span class="nf">get_atom_order</span><span class="p">(</span><span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">mol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Molecule</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">fragments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">constraints_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the order in which atoms should be added to the zmat from a 2D or a 3D representation.</span>

<span class="sd">    Args:</span>
<span class="sd">        xyz (dict, optional): The 3D coordinates.</span>
<span class="sd">        mol (Molecule, optional): The Molecule object.</span>
<span class="sd">        fragments (List[List[int]], optional):</span>
<span class="sd">            Fragments represented by the species, i.e., as in a VdW well or a TS.</span>
<span class="sd">            Entries are atom index lists of all atoms in a fragment, each list represents a different fragment.</span>
<span class="sd">        constraints_dict (dict, optional):</span>
<span class="sd">            A dictionary of atom constraints. The function will try to find an atom order in which all constrained atoms</span>
<span class="sd">            are after the atoms they are constraint to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[int]: The atom order, 0-indexed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either mol or xyz must be given.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fragments</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragments</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fragments</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))]</span>
        <span class="k">if</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fragments</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="n">order_fragments_by_constraints</span><span class="p">(</span><span class="n">fragments</span><span class="o">=</span><span class="n">fragments</span><span class="p">,</span> <span class="n">constraints_dict</span><span class="o">=</span><span class="n">constraints_dict</span><span class="p">)</span>

    <span class="n">atom_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
            <span class="n">atom_order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get_atom_order_from_mol</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">fragment</span><span class="p">,</span> <span class="n">constraints_dict</span><span class="o">=</span><span class="n">constraints_dict</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
            <span class="n">atom_order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get_atom_order_from_xyz</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">fragment</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">atom_order</span></div>


<div class="viewcode-block" id="get_atom_order_from_mol"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.get_atom_order_from_mol">[docs]</a><span class="k">def</span> <span class="nf">get_atom_order_from_mol</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">Molecule</span><span class="p">,</span>
                            <span class="n">fragment</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">constraints_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the order in which atoms should be added to the zmat from the 2D graph representation of the molecule.</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): The Molecule object.</span>
<span class="sd">        fragment (List[int], optional): Entries are 0-indexed atom indices to consider in the molecule.</span>
<span class="sd">                                        Only atoms within the fragment are considered.</span>
<span class="sd">        constraints_dict (dict, optional): A dictionary of atom constraints.</span>
<span class="sd">                                           The function will try to find an atom order in which all constrained atoms</span>
<span class="sd">                                           are after the atoms they are constraint to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[int]: The atom order, 0-indexed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fragment</span> <span class="o">=</span> <span class="n">fragment</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))</span>
    <span class="n">atoms_to_explore</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">constraint_atoms</span><span class="p">,</span> <span class="n">unsuccessful</span><span class="p">,</span> <span class="n">top_d</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">constraints_dict</span> <span class="o">=</span> <span class="n">constraints_dict</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">number_of_heavy_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_non_hydrogen</span><span class="p">()])</span>

    <span class="k">for</span> <span class="n">constraint_type</span><span class="p">,</span> <span class="n">constraint_list</span> <span class="ow">in</span> <span class="n">constraints_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">constraints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">constraint_list</span><span class="p">)</span>  <span class="c1"># A list of all constraint tuples.</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraint_list</span><span class="p">:</span>
            <span class="c1"># A list of the atoms being constraint to other atoms.</span>
            <span class="n">constraint_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Only the first atom in the constraint tuple is really constrained.</span>
        <span class="k">if</span> <span class="n">constraint_type</span> <span class="o">==</span> <span class="s1">&#39;D_group&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">constraint_indices</span> <span class="ow">in</span> <span class="n">constraint_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_d</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmats can only handle one D_group constraint at a time, got:</span><span class="se">\n</span><span class="si">{</span><span class="n">constraints_dict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># Determine the &quot;top&quot; of the *relevant branch* of this torsion</span>
                <span class="c1"># since the first atom (number 0) is the constrained one being changed,</span>
                <span class="c1"># this top is defined from the second atom in the torsion (number 1) to it.</span>
                <span class="n">top_d</span> <span class="o">=</span> <span class="n">determine_top_group_indices</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span>
                                                    <span class="n">atom1</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">constraint_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                    <span class="n">atom2</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">constraint_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                    <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">)):</span>
        <span class="c1"># Iterate through the atoms until a successful atom_order is reached.</span>
        <span class="n">atom_order</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="kc">None</span>
        <span class="c1"># Try determining a starting point as a heavy atom connected to no more than one heavy atom neighbor.</span>
        <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="c1"># Find a tail, e.g.: CH3-C-...</span>
            <span class="n">atom1_index</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">is_non_hydrogen</span><span class="p">()</span> \
                    <span class="ow">and</span> <span class="nb">sum</span><span class="p">([</span><span class="n">atom2</span><span class="o">.</span><span class="n">is_non_hydrogen</span><span class="p">()</span> <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span> <span class="o">&lt;=</span> <span class="mi">1</span> \
                    <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">constraint_atoms</span> \
                    <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unsuccessful</span> \
                    <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">top_d</span> \
                    <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">atom1_index</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If a tail could not be found (e.g., cyclohexane), just start from the first non-constrained heavy atom.</span>
            <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="n">atom1_index</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">is_non_hydrogen</span><span class="p">()</span> \
                        <span class="ow">and</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">constraint_atoms</span> \
                        <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unsuccessful</span> \
                        <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">top_d</span> \
                        <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">atom1_index</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Try hydrogens (an atom might be constraint to H, in which case H should come before that atom).</span>
                <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="n">atom1_index</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">is_hydrogen</span><span class="p">()</span> \
                            <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">constraint_atoms</span> \
                            <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unsuccessful</span> \
                            <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">top_d</span> \
                            <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">:</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="n">atom1_index</span>
                        <span class="k">break</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="s1">&#39;Could not determine a starting atom for the zmat&#39;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">atoms_to_explore</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">number_of_heavy_atoms</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># To have meaningful dihedrals for H&#39;s, add one H from each heavy atom before adding the heavy atoms.</span>
            <span class="n">heavy_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_non_hydrogen</span><span class="p">()]</span>
            <span class="n">hydrogens_0</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">heavy_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_hydrogen</span><span class="p">()]</span>
            <span class="n">hydrogens_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">heavy_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_hydrogen</span><span class="p">()]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hydrogens_0</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">hydrogens_1</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">constraint_atoms</span><span class="p">:</span>
                    <span class="n">hydrogen_0</span><span class="p">,</span> <span class="n">hydrogen_1</span> <span class="o">=</span> <span class="n">hydrogens_0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hydrogens_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">atom_index</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">heavy_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">heavy_atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                       <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">hydrogen_0</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">hydrogen_1</span><span class="p">)]:</span>
                        <span class="k">if</span> <span class="n">atom_index</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">:</span>
                            <span class="n">atom_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_index</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">atom_index</span> <span class="ow">in</span> <span class="n">constraint</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">atom_index</span> <span class="ow">in</span> <span class="n">fragment</span> <span class="ow">and</span> <span class="n">atom_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_order</span><span class="p">:</span>
                                <span class="n">atom_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_index</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                        <span class="n">atom1_index</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_order</span> <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">:</span>
                            <span class="n">atom_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom1_index</span><span class="p">)</span>
                <span class="n">atoms_to_explore</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="n">unexplored</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># Atoms purposely not added to atom_order due to a D_group constraint.</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms_to_explore</span><span class="p">):</span>
            <span class="c1"># Add all heavy atoms, consider branching and rings.</span>
            <span class="n">atom1_index</span> <span class="o">=</span> <span class="n">atoms_to_explore</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">atoms_to_explore</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">atom1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom1_index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">top_d</span> <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">in</span> <span class="n">fragment</span> <span class="ow">and</span> <span class="n">atom1_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_order</span><span class="p">:</span>
                <span class="n">atom_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom1_index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unexplored</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom1_index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">index2</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_order</span> <span class="ow">and</span> <span class="n">index2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms_to_explore</span> <span class="ow">and</span> <span class="n">index2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unexplored</span> \
                        <span class="ow">and</span> <span class="n">atom2</span><span class="o">.</span><span class="n">is_non_hydrogen</span><span class="p">():</span>
                    <span class="n">atoms_to_explore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="c1"># Add all hydrogen atoms.</span>
            <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">is_hydrogen</span><span class="p">():</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_order</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">top_d</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">:</span>
                    <span class="n">atom_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Now add top_d.</span>
        <span class="k">for</span> <span class="n">top_d_atom</span> <span class="ow">in</span> <span class="n">top_d</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">top_d_atom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_order</span> <span class="ow">and</span> <span class="n">top_d_atom</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">:</span>
                <span class="n">atom_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_d_atom</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_order</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
            <span class="k">break</span>

        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
            <span class="c1"># Loop through all constraint tuples, verify that the atoms are ordered in accordance with them.</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">c</span> <span class="ow">in</span> <span class="n">fragment</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constraint</span><span class="p">]):</span>
                <span class="c1"># Consider this constraint.</span>
                <span class="n">constraint_atom_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">constraint_atom</span><span class="p">)</span> <span class="k">for</span> <span class="n">constraint_atom</span> <span class="ow">in</span> <span class="n">constraint</span>
                                         <span class="k">if</span> <span class="n">constraint_atom</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">constraint_atom_order</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">constraint_atom_order</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">constraint_atom_order</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">entry</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">):</span>
                    <span class="c1"># Diff should only have negative entries.</span>
                    <span class="n">unsuccessful</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
            <span class="c1"># The atom order list answers all constraints criteria.</span>
            <span class="k">break</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># The outer for loop exhausted all possibilities and was unsuccessful.</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not derive an atom order from connectivity that answers all &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;constraint criteria:</span><span class="se">\n</span><span class="si">{</span><span class="n">constraints_dict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">atom_order</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_order</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not determine a unique atom order!</span><span class="se">\n</span><span class="s1">(</span><span class="si">{</span><span class="n">atom_order</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atom_order</span></div>


<div class="viewcode-block" id="get_atom_order_from_xyz"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.get_atom_order_from_xyz">[docs]</a><span class="k">def</span> <span class="nf">get_atom_order_from_xyz</span><span class="p">(</span><span class="n">xyz</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                            <span class="n">fragment</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the order in which atoms should be added to the zmat from the 3D geometry.</span>

<span class="sd">    Args:</span>
<span class="sd">        xyz (dict): The 3D coordinates.</span>
<span class="sd">        fragment (List[int], optional): Entries are 0-indexed atom indices to consider in the molecule.</span>
<span class="sd">                              Only atoms within the fragment are considered.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[int]: The atom order, 0-indexed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fragment</span> <span class="o">=</span> <span class="n">fragment</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])))</span>
    <span class="n">atom_order</span><span class="p">,</span> <span class="n">hydrogens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
                <span class="n">hydrogens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">atom_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">atom_order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">hydrogens</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">atom_order</span></div>


<div class="viewcode-block" id="consolidate_zmat"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.consolidate_zmat">[docs]</a><span class="k">def</span> <span class="nf">consolidate_zmat</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                     <span class="n">mol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Molecule</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">consolidation_tols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Consolidate (almost) identical vars in the zmat.</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        mol (Molecule, optional): The RMG molecule, used for atom types if not None,</span>
<span class="sd">                                  otherwise atom symbols from the zmat are used.</span>
<span class="sd">        consolidation_tols (dict, optional): Keys are &#39;R&#39;, &#39;A&#39;, &#39;D&#39;, values are floats representing absolute tolerance</span>
<span class="sd">                                             for consolidating almost equal internal coordinates.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: The consolidated zmat.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">consolidation_tols</span> <span class="o">=</span> <span class="n">consolidation_tols</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Assign defaults if needed:</span>
    <span class="k">if</span> <span class="s1">&#39;R&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">consolidation_tols</span><span class="p">:</span>
        <span class="n">consolidation_tols</span><span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_CONSOLIDATION_R_TOL</span>
    <span class="k">if</span> <span class="s1">&#39;A&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">consolidation_tols</span><span class="p">:</span>
        <span class="n">consolidation_tols</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_CONSOLIDATION_A_TOL</span>
    <span class="k">if</span> <span class="s1">&#39;D&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">consolidation_tols</span><span class="p">:</span>
        <span class="n">consolidation_tols</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_CONSOLIDATION_D_TOL</span>

    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span>  <span class="c1"># Make sure it is mutable.</span>

    <span class="n">keys_to_consolidate1</span><span class="p">,</span> <span class="n">keys_to_consolidate2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(),</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(),</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">()},</span> \
                                                 <span class="p">{</span><span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(),</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(),</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">()}</span>

    <span class="c1"># Identify potential keys to consolidate, save in keys_to_consolidate1.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">key1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">key1</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">for</span> <span class="n">keys</span> <span class="ow">in</span> <span class="n">keys_to_consolidate1</span><span class="p">[</span><span class="n">key1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]):</span>
            <span class="n">dup_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">key2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">key2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> \
                        <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">key1</span><span class="p">]</span> <span class="o">-</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">key2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">consolidation_tols</span><span class="p">[</span><span class="n">key1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dup_keys</span><span class="p">:</span>
                            <span class="n">dup_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dup_keys</span><span class="p">):</span>
                <span class="n">appended</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">dup_key</span> <span class="ow">in</span> <span class="n">dup_keys</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys_to_consolidate1</span><span class="p">[</span><span class="n">key1</span><span class="p">[</span><span class="mi">0</span><span class="p">]])):</span>
                        <span class="k">if</span> <span class="n">dup_key</span> <span class="ow">in</span> <span class="n">keys_to_consolidate1</span><span class="p">[</span><span class="n">key1</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">j</span><span class="p">]:</span>
                            <span class="c1"># There are two lists that must be combined during consolidation,</span>
                            <span class="c1"># but weren&#39;t identified as such (probably ony some variables are within the tolerance).</span>
                            <span class="n">keys_to_consolidate1</span><span class="p">[</span><span class="n">key1</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> \
                                <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">keys_to_consolidate1</span><span class="p">[</span><span class="n">key1</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dup_keys</span><span class="p">)))</span>
                            <span class="n">appended</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">appended</span><span class="p">:</span>
                    <span class="n">keys_to_consolidate1</span><span class="p">[</span><span class="n">key1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dup_keys</span><span class="p">)</span>

    <span class="c1"># Check atom types before consolidating, save in keys_to_consolidate2.</span>
    <span class="k">for</span> <span class="n">key_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">keys</span> <span class="ow">in</span> <span class="n">keys_to_consolidate1</span><span class="p">[</span><span class="n">key_type</span><span class="p">]:</span>
            <span class="n">atoms_dict</span><span class="p">,</span> <span class="n">indices_to_pop</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]):</span>
                    <span class="c1"># This is a dummy atom, don&#39;t check atoms, always consolidate.</span>
                    <span class="n">atoms_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;X&#39;</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]):</span>
                        <span class="c1"># Use atom types.</span>
                        <span class="n">atoms_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]]</span><span class="o">.</span><span class="n">atomtype</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Use symbols.</span>
                        <span class="n">atoms_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
            <span class="n">atoms_sets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">atoms_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atoms_set</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms_sets</span><span class="p">):</span>
                <span class="c1"># Check if the reverse is there as well, e.g., (&#39;C&#39;, &#39;H&#39;) is the same as (&#39;H&#39;, &#39;C&#39;)),</span>
                <span class="c1"># but if popping the first, don&#39;t pop the second...</span>
                <span class="c1"># also, avid popping symmetric tuples such as (&#39;O&#39;, &#39;O&#39;), or (&#39;H&#39;, &#39;C&#39;, &#39;H&#39;).</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">atoms_set</span><span class="p">))</span> <span class="ow">in</span> <span class="n">atoms_sets</span> \
                        <span class="ow">and</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">atoms_set</span><span class="p">))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">atom_set</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">atom_set</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms_sets</span><span class="p">)</span>
                                                               <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indices_to_pop</span><span class="p">]</span> \
                        <span class="ow">and</span> <span class="n">atoms_set</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">atoms_set</span><span class="p">)):</span>
                    <span class="n">indices_to_pop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms_sets</span><span class="p">))):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices_to_pop</span><span class="p">:</span>
                    <span class="n">atoms_sets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">atoms_tuple</span> <span class="ow">in</span> <span class="n">atoms_sets</span><span class="p">:</span>
                <span class="n">keys_to_consolidate2</span><span class="p">[</span><span class="n">key_type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">atoms_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                                       <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">atoms_tuple</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="o">==</span> <span class="n">atoms_tuple</span><span class="p">])</span>

    <span class="c1"># Consolidate the zmat.</span>
    <span class="k">for</span> <span class="n">key_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">keys</span> <span class="ow">in</span> <span class="n">keys_to_consolidate2</span><span class="p">[</span><span class="n">key_type</span><span class="p">]:</span>
            <span class="c1"># Generate a new key name.</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">new_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])):</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])):</span>
                <span class="n">new_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;X&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">([</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">])</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]):</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">key_type</span> <span class="o">+</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">key_type</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_indices</span><span class="p">)</span>

            <span class="c1"># Replace all occurrences in zmat[&#39;coords&#39;].</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])):</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">coord</span> <span class="ow">in</span> <span class="n">keys</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]]):</span>
                    <span class="n">new_coord</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                            <span class="n">new_coord</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_coord</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>
                    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_coord</span><span class="p">)</span>

            <span class="c1"># Replace all occurrences in zmat[&#39;vars&#39;] with the new key and an average value.</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
                <span class="n">new_value</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Adding a new value to an existing key.</span>
                <span class="n">found_key</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">keys_as_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_atom_indices_from_zmat_parameter</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">variable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">key_type</span><span class="p">:</span>
                        <span class="n">var_indices</span> <span class="o">=</span> <span class="n">get_atom_indices_from_zmat_parameter</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">key_indices</span> <span class="ow">in</span> <span class="n">var_indices</span> <span class="k">for</span> <span class="n">key_indices</span> <span class="ow">in</span> <span class="n">keys_as_indices</span><span class="p">]):</span>
                            <span class="n">found_key</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">for</span> <span class="n">key_indices</span> <span class="ow">in</span> <span class="n">keys_as_indices</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">key_indices</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_indices</span><span class="p">:</span>
                                    <span class="n">var_indices</span> <span class="o">+=</span> <span class="p">(</span><span class="n">key_indices</span><span class="p">,)</span>
                            <span class="n">new_consolidated_key</span> <span class="o">=</span> <span class="n">key_type</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                                <span class="n">new_consolidated_key</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> \
                                                        <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">var_index</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                                                  <span class="k">for</span> <span class="n">var_index</span> <span class="ow">in</span> <span class="n">var_indices</span><span class="p">])</span>
                            <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">new_consolidated_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">variable</span><span class="p">]</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="n">found_key</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">variable</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                            <span class="k">del</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="s1">&#39;Could not consolidate zmat&#39;</span><span class="p">)</span>
            <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">new_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">zmat</span></div>


<div class="viewcode-block" id="get_atom_indices_from_zmat_parameter"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.get_atom_indices_from_zmat_parameter">[docs]</a><span class="k">def</span> <span class="nf">get_atom_indices_from_zmat_parameter</span><span class="p">(</span><span class="n">param</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the atom indices from a zmat parameter.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &#39;R_0_2&#39; --&gt; ((0, 2),)</span>
<span class="sd">        &#39;A_0_1_2&#39; --&gt; ((0, 1, 2),) corresponding to angle 0-1-2</span>
<span class="sd">        &#39;D_0_1_2_4&#39; --&gt; ((0, 1, 2, 4),)</span>
<span class="sd">        &#39;R_0|0_3|4&#39; --&gt; ((0, 3), (0, 4))</span>
<span class="sd">        &#39;A_0|0|0_1|1|1_2|3|4&#39; --&gt; ((0, 1, 2), (0, 1, 3), (0, 1, 4)) corresponding to angles 0-1-2, 0-1-3, and 0-1-4</span>
<span class="sd">        &#39;D_0|0|0_1|1|1_2|3|4_5|6|9&#39; --&gt; ((0, 1, 2, 5), (0, 1, 3, 6), (0, 1, 4, 9))</span>
<span class="sd">        &#39;RX_0_2&#39; --&gt; ((0, 2),)</span>

<span class="sd">    Args:</span>
<span class="sd">        param (str): The zmat parameter.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: Entries are tuples of indices, each describing R, A, or D parameters.</span>
<span class="sd">               The tuple entries for R, A, and D types are of lengths 2, 3, and 4, respectively.</span>
<span class="sd">               The number of tuple entries depends on the number of consolidated parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">index_groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># exclude the type char (&#39;R&#39;, &#39;A&#39;, or &#39;D&#39;)</span>
    <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="n">splits</span><span class="p">:</span>
        <span class="n">index_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">index_group</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">index_group</span> <span class="ow">in</span> <span class="n">index_groups</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_parameter_from_atom_indices"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.get_parameter_from_atom_indices">[docs]</a><span class="k">def</span> <span class="nf">get_parameter_from_atom_indices</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                    <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">],</span>
                                    <span class="n">xyz_indexed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the zmat parameter from the atom indices.</span>
<span class="sd">    If indices are of length two, three, or four, an R, A, or D parameter is returned, respectively.</span>

<span class="sd">    If a requested parameter represents an angle split by a dummy atom,</span>
<span class="sd">    combine the two dummy angles to get the original angle.</span>
<span class="sd">    In this case, a list of the two corresponding parameters will be returned.</span>

<span class="sd">    Examples:</span>
<span class="sd">        [0, 2] --&gt; &#39;R_0_2&#39;, or &#39;R_0|1_2_5&#39;, etc.</span>
<span class="sd">        [0, 2, 4] --&gt; &#39;A_0_2_4&#39;, or a respective consolidated key</span>
<span class="sd">        [0, 2, 4, 9] --&gt; &#39;D_0_2_4_9&#39;, or a respective consolidated key</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        indices (Union[list, tuple]): Entries are 0-indices of atoms, list is of length 2, 3, or 4.</span>
<span class="sd">        xyz_indexed (bool, optional): Whether the atom indices relate to the xyz (and the zmat map will be used)</span>
<span class="sd">                                      or they already relate to the zmat. Default is ``True`` (relate to xyz).</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If ``indices`` are of wrong type.</span>
<span class="sd">        ZMatError: If ``indices`` has a wrong length, or not all indices are in the zmat map.</span>

<span class="sd">    Returns: Union[str, tuple, list]</span>
<span class="sd">        The corresponding zmat parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;indices must be a list, got </span><span class="si">{</span><span class="n">indices</span><span class="si">}</span><span class="s1"> which is a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;indices must be of length 2, 3, or 4, got </span><span class="si">{</span><span class="n">indices</span><span class="si">}</span><span class="s1"> (length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xyz_indexed</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Not all indices (</span><span class="si">{</span><span class="n">indices</span><span class="si">}</span><span class="s1">) are in the zmat map values (</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">key_by_val</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Not all indices (</span><span class="si">{</span><span class="n">indices</span><span class="si">}</span><span class="s1">) are in the zmat map keys (</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">KEY_FROM_LEN</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)]]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="c1"># It&#39;s a non-consolidated key.</span>
        <span class="k">return</span> <span class="n">key</span>
    <span class="c1"># It&#39;s a consolidated key.</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">KEY_FROM_LEN</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span> <span class="ow">and</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">get_atom_indices_from_zmat_parameter</span><span class="p">(</span><span class="n">var</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">var</span>
    <span class="c1"># If no value found, check whether this is an angle split by a dummy atom.</span>
    <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># 180 degree angles aren&#39;t given explicitly in the zmat,</span>
        <span class="c1"># they are separated in to two angles using a dummy atom, check if this is the case here.</span>
        <span class="n">dummy_indices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;X&#39;</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>
        <span class="n">param1</span> <span class="o">=</span> <span class="s1">&#39;AX_</span><span class="si">{0}</span><span class="s1">_</span><span class="si">{1}</span><span class="s1">_</span><span class="si">{2}</span><span class="s1">&#39;</span>
        <span class="n">all_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">dummy_str_index</span> <span class="ow">in</span> <span class="n">dummy_indices</span><span class="p">:</span>
            <span class="n">var1</span> <span class="o">=</span> <span class="n">param1</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dummy_str_index</span><span class="p">)</span> \
                <span class="k">if</span> <span class="n">param1</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dummy_str_index</span><span class="p">)</span> <span class="ow">in</span> <span class="n">all_parameters</span> <span class="ow">and</span> <span class="n">var1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">var1</span>
            <span class="n">var1</span> <span class="o">=</span> <span class="n">param1</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dummy_str_index</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> \
                <span class="k">if</span> <span class="n">param1</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dummy_str_index</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">all_parameters</span> <span class="ow">and</span> <span class="n">var1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">var1</span>
            <span class="k">if</span> <span class="n">var1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param2a</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;AX_</span><span class="si">{</span><span class="n">dummy_str_index</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">param2b</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;AX_</span><span class="si">{</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">dummy_str_index</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">var2</span> <span class="o">=</span> <span class="n">param2a</span> <span class="k">if</span> <span class="n">param2a</span> <span class="ow">in</span> <span class="n">all_parameters</span> <span class="ow">and</span> <span class="n">var2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">var2</span>
                <span class="n">var2</span> <span class="o">=</span> <span class="n">param2b</span> <span class="k">if</span> <span class="n">param2b</span> <span class="ow">in</span> <span class="n">all_parameters</span> <span class="ow">and</span> <span class="n">var2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">var2</span>
                <span class="k">if</span> <span class="n">var2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">var1</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">var1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">var2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">]</span>
    <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not find a key corresponding to </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">indices</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_compare_zmats</span><span class="p">(</span><span class="n">zmat1</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                   <span class="n">zmat2</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                   <span class="n">r_tol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">a_tol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">d_tol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">symmetric_torsions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare two zmats. The zmats must have identical variables (i.e., derived from the same connectivity or ordered xyz,</span>
<span class="sd">    using the same constraints).</span>
<span class="sd">    This function does not make use of the zmat map, but does check that it is identical.</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat1 (dict): zmat1.</span>
<span class="sd">        zmat2 (dict): zmat2.</span>
<span class="sd">        r_tol (float, optional): A tolerance for comparing distances.</span>
<span class="sd">        a_tol (float, optional): A tolerance for comparing angles.</span>
<span class="sd">        d_tol (float, optional): A tolerance for comparing dihedral angles.</span>
<span class="sd">        symmetric_torsions (dict, optional): Keys are tuples of 0-indexed scan indices, values are internal rotation</span>
<span class="sd">                                             symmetry numbers (sigma). Conformers which only differ by an integer number</span>
<span class="sd">                                             times 360 degrees / sigma are considered identical.</span>
<span class="sd">        verbose (bool, optional): Whether to print a reason for determining the zmats are different if they are,</span>
<span class="sd">                                  ``True`` to print.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If the zmats are of wrong type or don&#39;t have all attributes.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: Whether the two zmats represent the same conformation to the desired tolerance. ``True`` if they do.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zmat1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zmat2</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmats must be dictionaries, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">zmat1</span><span class="p">)</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">zmat2</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">zmat1</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmat1 is empty! Got </span><span class="si">{</span><span class="n">zmat1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">zmat2</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmat2 is empty! Got </span><span class="si">{</span><span class="n">zmat2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;symbols&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat1</span> <span class="ow">or</span> <span class="s1">&#39;coords&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat1</span> <span class="ow">or</span> <span class="s1">&#39;vars&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat1</span> \
            <span class="ow">or</span> <span class="s1">&#39;symbols&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat2</span> <span class="ow">or</span> <span class="s1">&#39;coords&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat2</span> <span class="ow">or</span> <span class="s1">&#39;vars&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmats must contain the &quot;symbols&quot;, &quot;coords&quot;, and &quot;vars&quot; keys, got: &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">zmat1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">zmat2</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="n">r_tol</span> <span class="ow">or</span> <span class="n">DEFAULT_COMPARISON_R_TOL</span><span class="p">,</span>
           <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">a_tol</span> <span class="ow">or</span> <span class="n">DEFAULT_COMPARISON_A_TOL</span><span class="p">,</span>
           <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="n">d_tol</span> <span class="ow">or</span> <span class="n">DEFAULT_COMPARISON_D_TOL</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">zmat1</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">zmat2</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmats have different maps:</span><span class="se">\n</span><span class="si">{</span><span class="n">zmat1</span><span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">zmat2</span><span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat1</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">zmat2</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmats have different symbols:</span><span class="se">\n</span><span class="si">{</span><span class="n">zmat1</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">zmat2</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">zmat1</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zmat2</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmats differ since the coordinates </span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s1"> are missing from zmat2.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">zmat1</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">var</span><span class="p">],</span> <span class="n">zmat2</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">var</span><span class="p">]</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val1</span> <span class="o">-</span> <span class="n">val2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">[</span><span class="n">key_type</span><span class="p">]:</span>
                    <span class="c1"># The dihedrals are not the same, but check whether they disagree by an integer times 360 / sigma.</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">symmetric_torsions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;D&#39;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                        <span class="n">vars_</span> <span class="o">=</span> <span class="n">get_atom_indices_from_zmat_parameter</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                        <span class="c1"># vars is generated from var as &#39;D_0|0_1|1_2|3|_5|6&#39; --&gt; ((0, 1, 2, 5), (0, 1, 3, 6)).</span>
                        <span class="k">for</span> <span class="n">var_</span> <span class="ow">in</span> <span class="n">vars_</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">symmetric_torsion</span> <span class="ow">in</span> <span class="n">symmetric_torsions</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="c1"># Check the pivots only (not the entire four torsion indices).</span>
                                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">var_</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">symmetric_torsion</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]):</span>
                                    <span class="n">sigma</span> <span class="o">=</span> <span class="n">symmetric_torsions</span><span class="p">[</span><span class="n">symmetric_torsion</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val1</span> <span class="o">-</span> <span class="n">val2</span><span class="p">)</span>
                            <span class="n">rotation_symmetry</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">/</span> <span class="n">sigma</span>  <span class="c1"># The rotation symmetry in degrees.</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">diff</span> <span class="o">-</span> <span class="n">rotation_symmetry</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">[</span><span class="n">key_type</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sigma</span><span class="p">)]):</span>
                                <span class="n">sigma</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Mark this test as unsuccessful to return False below.</span>
                    <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zmats differ since the respective values for var </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1"> in zmat1 and zmat2 &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">val1</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">val2</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">) differ by </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">val1</span> <span class="o">-</span> <span class="n">val2</span><span class="p">)</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">, which is greater &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;than the required tolerance of </span><span class="si">{</span><span class="n">tol</span><span class="p">[</span><span class="n">key_type</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="get_all_neighbors"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.get_all_neighbors">[docs]</a><span class="k">def</span> <span class="nf">get_all_neighbors</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">Molecule</span><span class="p">,</span>
                      <span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get atom indices of all neighbors of an atom in a molecule.</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): The RMG molecule with connectivity information.</span>
<span class="sd">        atom_index (int): The index of the atom whose neighbors are requested.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[int]: Atom indices of all neighbors of the requested atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_index</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">neighbors</span></div>


<div class="viewcode-block" id="is_atom_in_new_fragment"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.is_atom_in_new_fragment">[docs]</a><span class="k">def</span> <span class="nf">is_atom_in_new_fragment</span><span class="p">(</span><span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                            <span class="n">zmat</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]],</span>
                            <span class="n">fragments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">skip_atoms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Whether an atom is present in a new fragment that hasn&#39;t been added to the zmat yet,</span>
<span class="sd">    and therefore atom assignment should not be done based on connectivity.</span>

<span class="sd">    Args:</span>
<span class="sd">        atom_index (int): The 0-index of the atom in the molecule or cartesian coordinates to be added.</span>
<span class="sd">                          (``n`` and ``atom_index`` refer to the same atom, but it might have different indices</span>
<span class="sd">                          in the zmat/molecule/xyz/fragments)</span>
<span class="sd">        zmat (dict): The zmat.</span>
<span class="sd">        skip_atoms (list): Atoms in the zmat map to ignore when checking fragments.</span>
<span class="sd">        fragments (List[List[int]], optional):</span>
<span class="sd">            Fragments represented by the species, i.e., as in a VdW well or a TS.</span>
<span class="sd">            Entries are atom index lists of all atoms in a fragment, each list represents a different fragment.</span>
<span class="sd">            indices are 0-indexed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: Whether to consider connectivity for assigning atoms in z-mat variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skip_atoms</span> <span class="o">=</span> <span class="n">skip_atoms</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">fragments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom_index</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">z_index</span> <span class="ow">in</span> <span class="n">skip_atoms</span> <span class="ow">or</span> <span class="n">frag_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fragment</span>
                        <span class="k">for</span> <span class="n">z_index</span><span class="p">,</span> <span class="n">frag_index</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]):</span>
                    <span class="c1"># All atoms considered thus far are not in the current fragment, connectivity is meaningless.</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="up_param"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.up_param">[docs]</a><span class="k">def</span> <span class="nf">up_param</span><span class="p">(</span><span class="n">param</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
             <span class="n">increment</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">increment_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Increase the indices represented by a zmat parameter.</span>

<span class="sd">    Args:</span>
<span class="sd">        param (str): The zmat parameter.</span>
<span class="sd">        increment (int, optional): The increment to increase by.</span>
<span class="sd">        increment_list (list, optional): Entries are individual indices to use when incrementing the ``param`` indices.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ZMatError: If neither ``increment`` nor ``increment_list`` were specified,</span>
<span class="sd">                   or if the increase resulted in a negative number.</span>

<span class="sd">    Returns: str</span>
<span class="sd">        The new parameter with increased indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">increment</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">increment_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="s1">&#39;Either increment or increment_list must be specified.&#39;</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">get_atom_indices_from_zmat_parameter</span><span class="p">(</span><span class="n">param</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">increment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">index</span> <span class="ow">and</span> <span class="n">increment</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">index</span> <span class="o">+</span> <span class="n">increment</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">increment_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The number of increments in </span><span class="si">{</span><span class="n">increment_list</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">increment_list</span><span class="p">)</span><span class="si">}</span><span class="s1"> is different than &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;the number of indices to increment </span><span class="si">{</span><span class="n">indices</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="n">new_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">inc</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">inc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">increment_list</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">new_indices</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ZMatError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Got a negative zmat index when bumping </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1"> by </span><span class="si">{</span><span class="n">increment</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">new_indices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">new_indices</span><span class="p">]</span>
    <span class="n">new_param</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">param</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">new_indices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_param</span></div>


<div class="viewcode-block" id="remove_1st_atom"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.remove_1st_atom">[docs]</a><span class="k">def</span> <span class="nf">remove_1st_atom</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove the first atom of a zmat.</span>
<span class="sd">    Note: The first atom in &#39;symbols&#39; with map key 0 is removed,</span>
<span class="sd">    it is not necessarily the first atom in the corresponding xyz with map value 0.</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat to process.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: The updated zmat.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zmat</span> <span class="o">=</span> <span class="n">remove_1st_atom_references</span><span class="p">(</span><span class="n">zmat</span><span class="o">=</span><span class="n">zmat</span><span class="p">)</span>
    <span class="n">new_symbols</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">new_coords</span><span class="p">,</span> <span class="n">removed_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">removed_vars</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">coord</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">new_coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">up_param</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">increment</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">up_param</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">increment</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">up_param</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">increment</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="k">else</span> <span class="kc">None</span><span class="p">))</span>
    <span class="n">new_coords</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_coords</span><span class="p">)</span>
    <span class="n">new_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">up_param</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">increment</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed_vars</span><span class="p">}</span>
    <span class="n">val_0</span> <span class="o">=</span> <span class="n">map_index_to_int</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">keys_of_x_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;X&#39;</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>
    <span class="n">new_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="n">map_index_to_int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">map_index_to_int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">val_0</span> <span class="k">else</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">new_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys_of_x_atoms</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;X</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">new_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;symbols&#39;</span><span class="p">:</span> <span class="n">new_symbols</span><span class="p">,</span> <span class="s1">&#39;coords&#39;</span><span class="p">:</span> <span class="n">new_coords</span><span class="p">,</span> <span class="s1">&#39;vars&#39;</span><span class="p">:</span> <span class="n">new_vars</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">:</span> <span class="n">new_map</span><span class="p">}</span></div>


<div class="viewcode-block" id="remove_1st_atom_references"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.remove_1st_atom_references">[docs]</a><span class="k">def</span> <span class="nf">remove_1st_atom_references</span><span class="p">(</span><span class="n">zmat</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove references for the 1st atom (index 0) in the zmat in all coords and respective vars</span>
<span class="sd">    from the 5th atom (index 4) on. I.e., the 2nd, 3rd, and 4th atoms can include references to the 1st atom.</span>

<span class="sd">    Args:</span>
<span class="sd">        zmat (dict): The zmat to process.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: The updated zmat.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zmat</span> <span class="o">=</span> <span class="n">zmat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">xyz_coords</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">new_zmat_coords</span><span class="p">,</span> <span class="n">new_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]):</span>
        <span class="n">new_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;_0&#39;</span> <span class="ow">in</span> <span class="n">new_coords</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">xyz_coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">xyz_coords</span> <span class="o">=</span> <span class="n">zmat_to_coords</span><span class="p">(</span><span class="n">zmat</span><span class="o">=</span><span class="n">zmat</span><span class="p">,</span> <span class="n">keep_dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">get_atom_indices_from_zmat_parameter</span><span class="p">(</span><span class="n">new_coords</span><span class="p">[</span><span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">new_index</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">new_index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                        <span class="n">new_index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">new_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">if</span> <span class="n">index</span> <span class="k">else</span> <span class="n">new_index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
                    <span class="n">new_val</span> <span class="o">=</span> <span class="n">calculate_param</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">xyz_coords</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">new_indices</span><span class="p">)</span>
                    <span class="n">new_coords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">new_coords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">new_indices</span><span class="p">])</span>
                    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;vars&#39;</span><span class="p">][</span><span class="n">new_coords</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_val</span>
        <span class="n">new_zmat_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_coords</span><span class="p">))</span>
    <span class="n">zmat</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_zmat_coords</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">zmat</span></div>


<div class="viewcode-block" id="map_index_to_int"><a class="viewcode-back" href="../../../api/zmat.html#arc.species.zmat.map_index_to_int">[docs]</a><span class="k">def</span> <span class="nf">map_index_to_int</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a zmat map value, e.g., 1 or &#39;X15&#39;, into an int, e.g., 1 or 15.</span>

<span class="sd">    Args:</span>
<span class="sd">        index (Union[int, str]): The map index.</span>

<span class="sd">    Returns: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">index</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">char</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Expected either an int or a string on the format &quot;X15&quot;, got </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018-2024, Alon Grinberg Dana

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>