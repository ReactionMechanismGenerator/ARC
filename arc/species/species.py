#!/usr/bin/env python
# encoding: utf-8

"""
A module for representing species
"""

from __future__ import (absolute_import, division, print_function, unicode_literals)
import os
import numpy as np
import datetime

from rdkit import Chem
from rdkit.Chem import rdMolTransforms as rdMT
from rdkit.Chem.rdchem import EditableMol as RDMol
import openbabel as ob
import pybel as pyb

from arkane.common import ArkaneSpecies, symbol_by_number
from arkane.statmech import determine_qm_software, is_linear
from rmgpy.molecule.converter import toOBMol
from rmgpy.molecule.element import getElement
from rmgpy.molecule.molecule import Atom, Molecule
from rmgpy.qm.qmdata import QMData
from rmgpy.qm.symmetry import PointGroupCalculator
from rmgpy.reaction import Reaction
from rmgpy.species import Species
from rmgpy.statmech import NonlinearRotor, LinearRotor
from rmgpy.molecule.resonance import generate_kekule_structure
from rmgpy.transport import TransportData
from rmgpy.exceptions import InvalidAdjacencyListError

from arc.common import get_logger, get_atom_radius, get_center_of_mass
from arc.arc_exceptions import SpeciesError, RotorError, InputError, TSError
from arc.settings import arc_path, default_ts_methods, valid_chars, minimum_barrier
from arc.parser import parse_xyz_from_file, parse_dipole_moment, parse_polarizability
from arc.species.converter import get_xyz_string, get_xyz_matrix, rdkit_conf_from_mol, standardize_xyz_string,\
    molecules_from_xyz, rmg_mol_from_inchi, order_atoms_in_mol_list, check_isomorphism
from arc.ts import atst

##################################################################

logger = get_logger()


class ARCSpecies(object):
    """
    ARCSpecies class

    ====================== ============= ===============================================================================
    Attribute              Type          Description
    ====================== ============= ===============================================================================
    `label`                 ``str``      The species' label
    `multiplicity`          ``int``      The species' multiplicity. Can be determined from adjlist/smiles/xyz
                                           The algorithm assumes it's either a singlet or a doublet
    `charge`                ``int''      The species' net charge. Assumed to be 0 be default.
    `number_of_radicals`    ``int``      The number of radicals (inputted by the user, ARC won't attempt to determine
                                           it). Defaults to None. Important, e.g., if a Species is a bi-rad singlet,
                                           in which case the job should be unrestricted, but the multiplicity does not
                                           have the required information to make that decision (r vs. u)
    `e_elect`               ``float``    The total electronic energy (without ZPE) of the species
                                            at the chosen sp level, in kJ/mol
    `is_ts`                 ``bool``     Whether or not the species represents a transition state
    `number_of_rotors`      ``int``      The number of potential rotors to scan
    `rotors_dict`           ``dict``     A dictionary of rotors. structure given below.
    `conformers`            ``list``     A list of selected conformers XYZs
    `conformer_energies`    ``list``     A list of conformers E0 (in J/mol)
    `initial_xyz`           ``string``   The initial geometry guess
    `final_xyz`             ``string``   The optimized species geometry
    `opt_level`             ``string``   Level of theory for geometry optimization. Saved for archiving.
    `number_of_atoms`       ``int``      The number of atoms in the species/TS
    `mol`                   ``Molecule`` An RMG:`Molecule` object used for BAC determination.
                                           Atom order corresponds to the order in .initial_xyz
    `mol_list`              ``list``     A list of localized structures generated from 'mol', if possible
    `rmg_species`           ``Species``  An RMG Species object to be converted to an ARCSpecies object
    `bond_corrections`      ``dict``     The bond additivity corrections (BAC) to be used. Determined from the structure
                                           if not directly given.
    `run_time`              ``timedelta`` Overall species execution time
    `t1`                    ``float``    The T1 diagnostic parameter from Molpro
    `neg_freqs_trshed`      ``list``     A list of negative frequencies this species was troubleshooted for
    `generate_thermo`       ``bool``     Whether ot not to calculate thermodynamic properties for this species
    `thermo`                ``HeatCapacityModel``  The thermodata calculated by ARC
    `rmg_thermo`            ``HeatCapacityModel``  The thermodata generated by RMG for comparison
    `long_thermo_description`  ``str``   A description for the species entry in the thermo library outputed
    `ts_methods`            ``list``     Methods to try for generating TS guesses. If Species is a TS and `ts_methods`
                                           is an empty list, then xyz (user guess) must be given.
                                           If `ts_methods` is None, it will be set to the default methods
    `ts_guesses`            ``list``     A list of TSGuess objects for each of the specified methods
    `successful_methods`    ``list``     Methods used to generate a TS guess that successfully generated an XYZ guess
    `unsuccessful_methods`  ``list``     Methods used to generate a TS guess that were unsuccessfully
    `chosen_ts`             ``int``      The TSGuess index corresponding to the chosen TS conformer used for
                                            optimization
    `chosen_ts_method`      ``str``      The TS method that was actually used for optimization
    `ts_conf_spawned`       ``bool``     Whether conformers were already spawned for the Species (representing a TS)
                                           based on its TSGuess objects
    `ts_number`             ``int``      An auto-generated number associating the TS ARCSpecies object with the
                                           corresponding ARCReaction object
    `ts_report`             ``str``      A description of all methods used for guessing a TS and their ranking
    `rxn_label`             ``str``      The reaction string (relevant for TSs)
    `arkane_file`           ``str``      Path to the Arkane Species file generated in Processor
    `yml_path`              ``str``      Path to an Arkane YAML file representing a species (for loading the object)
    `checkfile`             ``str``      The local path to the latest checkfile by Gaussian for the species
    `conformer_checkfiles`  ``dict``     A dictionary of conformer checkfiles. Keys are conformer indices,
                                           Values are local paths to check files
    `external_symmetry`     ``int``      The external symmetry of the species (not including rotor symmetries)
    `optical_isomers`       ``int``      Whether (=2) or not (=1) the species has chiral center/s
    `transport_data`        ``TransportData``  A placeholder for updating transport properties after Lennard-Jones
                                                 calculation (using OneDMin)
    `r_min`            ``int``           The minimum radius for OneDMin in Angstrom
    `r_max`            ``int``           The maximum radius for OneDMin in Angstrom
    ====================== ============= ===============================================================================

    Dictionary structure:

*   rotors_dict: {1: {'pivots': pivots_list,
                      'top': top_list,
                      'scan': scan_list,
                      'success': ``bool``.
                      'invalidation_reason': ``str``,
                      'times_dihedral_set': ``int``,
                      'scan_path': <path to scan output file>},
                      'max_e': ``float``,  # in kJ/mol
                      'symmetry': ``int``,
                  2: {}, ...
                 }
    """
    def __init__(self, is_ts=False, rmg_species=None, mol=None, label=None, xyz=None, multiplicity=None, charge=None,
                 smiles='', adjlist='', inchi='', bond_corrections=None, generate_thermo=True, species_dict=None,
                 yml_path=None, ts_methods=None, ts_number=None, rxn_label=None, external_symmetry=None,
                 optical_isomers=None, run_time=None, checkfile=None, number_of_radicals=None, r_min=None, r_max=None):
        self.t1 = None
        self.ts_number = ts_number
        self.conformers = list()
        self.conformer_energies = list()
        self.xyzs = list()  # used for conformer search
        self.initial_xyz = None
        self.thermo = None
        self.rmg_thermo = None
        self.rmg_kinetics = None
        self._number_of_atoms = None
        self._number_of_heavy_atoms = None
        self.mol = mol
        self.mol_list = None
        self.multiplicity = multiplicity
        self.number_of_radicals = number_of_radicals
        self.external_symmetry = external_symmetry
        self.optical_isomers = optical_isomers
        self.charge = charge
        self.run_time = run_time
        self.checkfile = checkfile
        self.conformer_checkfiles = dict()
        self.most_stable_conformer = None
        self.transport_data = TransportData()
        self.r_min = r_min
        self.r_max = r_max

        if species_dict is not None:
            # Reading from a dictionary
            self.from_dict(species_dict=species_dict)
        else:
            # Not reading from a dictionary
            self.is_ts = is_ts
            self.ts_conf_spawned = False
            self.e_elect = None
            self.arkane_file = None
            if self.is_ts:
                if ts_methods is None:
                    self.ts_methods = default_ts_methods
                elif isinstance(ts_methods, list):
                    self.ts_methods = ts_methods
                    if not self.ts_methods:
                        self.ts_methods = ['user guess']
                else:
                    raise TSError('ts_methods must be a list, got {0} of type {1}'.format(ts_methods, type(ts_methods)))
            else:
                self.ts_methods = None
            self.rxn_label = rxn_label
            self.ts_guesses = list()
            self.successful_methods = list()
            self.unsuccessful_methods = list()
            self.chosen_ts_method = None
            self.chosen_ts = None
            self.generate_thermo = generate_thermo if not self.is_ts else False
            self.long_thermo_description = ''
            self.opt_level = None
            self.ts_report = ''
            self.yml_path = yml_path
            self.final_xyz = None
            self.number_of_rotors = 0
            self.rotors_dict = dict()
            self.rmg_species = rmg_species
            self.process_xyz(xyz)
            if bond_corrections is None:
                self.bond_corrections = dict()
            else:
                self.bond_corrections = bond_corrections

            if self.yml_path is not None:
                # a YAML path was given
                self.from_yml_file(label)
                if label is not None:
                    self.label = label
            elif self.rmg_species is not None:
                # an RMG Species was given
                if not isinstance(self.rmg_species, Species):
                    raise SpeciesError('The rmg_species parameter has to be a valid RMG Species object.'
                                       ' Got: {0}'.format(type(self.rmg_species)))
                if not self.rmg_species.molecule:
                    raise SpeciesError('If an RMG Species given, it must have a non-empty molecule list')
                if not self.rmg_species.label and not label:
                    raise SpeciesError('If an RMG Species given, it must have a label or a label must be given'
                                       ' separately')
                if label:
                    self.label = label
                else:
                    self.label = self.rmg_species.label
                self.mol_list = self.rmg_species.molecule
                if self.mol is None:
                    self.mol = self.rmg_species.molecule[0]
                    if len(self.rmg_species.molecule) == 1:
                        self.mol_list = self.rmg_species.generate_resonance_structures(
                            keep_isomorphic=False, filter_structures=True)
                    self.mol_list = self.rmg_species.molecule
                    if len(self.mol_list) > 1:
                        logger.info('Using localized structure {0} of species {1} for BAC determination. To use a'
                                    ' different structure, pass the RMG:Molecule object in the `mol` parameter'.format(
                                      self.mol.toSMILES(), self.label))
                self.multiplicity = self.rmg_species.molecule[0].multiplicity
                self.charge = self.rmg_species.molecule[0].getNetCharge()

            if label is not None:
                self.label = label
            if multiplicity is not None:
                self.multiplicity = multiplicity
            if charge is not None:
                self.charge = charge
            if self.mol is None:
                if adjlist:
                    self.mol = Molecule().fromAdjacencyList(adjlist=adjlist)
                elif inchi:
                    self.mol = rmg_mol_from_inchi(inchi)
                elif smiles:
                    self.mol = Molecule(SMILES=smiles)
            if not self.is_ts and self.mol is None and self.generate_thermo:
                logger.warning('No structure (SMILES, adjList, RMG:Species, or RMG:Molecule) was given for species'
                               ' {0}, NOT using bond additivity corrections (BAC) for thermo computation.'
                               .format(self.label))

            if not self.is_ts:
                # Perceive molecule from xyz coordinates
                # This also populates mol_list
                if self.final_xyz or self.initial_xyz or self.conformers:
                    self.mol_from_xyz()
                # Generate bond list for applying bond corrections
                if not self.bond_corrections and self.mol is not None:
                    self.bond_corrections = enumerate_bonds(self.mol)
                    if self.bond_corrections:
                        self.long_thermo_description += 'Bond corrections: {0}\n'.format(self.bond_corrections)

            if self.mol is not None and self.mol_list is None:
                mol_copy = self.mol.copy(deep=True)
                self.mol_list = mol_copy.generate_resonance_structures(keep_isomorphic=False, filter_structures=True)
            elif not self.bond_corrections and self.generate_thermo:
                logger.warning('Cannot determine bond additivity corrections (BAC) for species {0} based on xyz'
                               ' coordinates only. For better thermoproperties, provide bond corrections.')

            self.neg_freqs_trshed = list()

        if self.multiplicity is None:
            self.determine_multiplicity(smiles, adjlist, self.mol)
            logger.debug('No multiplicity specified for {0}, assuming {1}.'.format(self.label, self.multiplicity))
        if self.charge is None:
            logger.debug('No charge specified for {0}, assuming charge 0.'.format(self.label))
            self.charge = 0
        if self.multiplicity is not None and self.multiplicity < 1:
            raise SpeciesError('Multiplicity for species {0} is lower than 1. Got: {1}'.format(
                self.label, self.multiplicity))
        if not isinstance(self.multiplicity, int) and self.multiplicity is not None:
            raise SpeciesError('Multiplicity for species {0} is not an integer. Got: {1}, a {2}'.format(
                self.label, self.multiplicity, type(self.multiplicity)))
        if not isinstance(self.charge, int):
            raise SpeciesError('Charge for species {0} is not an integer (got {1}, a {2})'.format(
                self.label, self.charge, type(self.charge)))
        if not self.is_ts and self.initial_xyz is None and self.final_xyz is None and self.mol is None\
                and not self.conformers:
            raise SpeciesError('No structure (xyz, SMILES, adjList, RMG:Species, or RMG:Molecule) was given for'
                               ' species {0}'.format(self.label))
        if self.label is None:
            raise SpeciesError('A label must be specified for an ARCSpecies object.')
        # Check that `label` is valid, since it is used for folder names
        for char in self.label:
            if char not in valid_chars:
                raise SpeciesError('Species label {0} contains an invalid character: "{1}"'.format(self.label, char))

    @property
    def number_of_atoms(self):
        """The number of atoms in the species"""
        if self._number_of_atoms is None:
            if self.mol is not None:
                self._number_of_atoms = len(self.mol.atoms)
            elif self.final_xyz is not None or self.initial_xyz is not None:
                xyz = self.final_xyz or self.initial_xyz
                self._number_of_atoms = len(xyz.splitlines())
            elif self.is_ts:
                for ts_guess in self.ts_guesses:
                    if ts_guess.xyz is not None:
                        self._number_of_atoms = len(ts_guess.xyz.splitlines())
        return self._number_of_atoms

    @number_of_atoms.setter
    def number_of_atoms(self, value):
        """Allow setting number of atoms, e.g. a TS might not have Molecule or xyz when initialized"""
        self._number_of_atoms = value

    @property
    def number_of_heavy_atoms(self):
        """The number of heavy (non hydrogen) atoms in the species"""
        if self._number_of_heavy_atoms is None:
            if self.mol is not None:
                self._number_of_heavy_atoms = len([atom for atom in self.mol.atoms if atom.isNonHydrogen()])
            elif self.final_xyz is not None or self.initial_xyz is not None:
                xyz = self.final_xyz or self.initial_xyz
                self._number_of_heavy_atoms = len([line for line in xyz.splitlines() if line.split()[0] != 'H'])
            elif self.is_ts:
                for ts_guess in self.ts_guesses:
                    if ts_guess.xyz is not None:
                        self._number_of_heavy_atoms =\
                            len([line for line in ts_guess.xyz.splitlines() if line.split()[0] != 'H'])
        return self._number_of_heavy_atoms

    @number_of_heavy_atoms.setter
    def number_of_heavy_atoms(self, value):
        """Allow setting number of heavy atoms, e.g. a TS might not have Molecule or xyz when initialized"""
        self._number_of_heavy_atoms = value

    def as_dict(self):
        """A helper function for dumping this object as a dictionary in a YAML file for restarting ARC"""
        species_dict = dict()
        species_dict['is_ts'] = self.is_ts
        species_dict['E0'] = self.e_elect
        species_dict['arkane_file'] = self.arkane_file
        if self.r_min is not None:
            species_dict['r_min'] = self.r_min
        if self.r_max is not None:
            species_dict['r_max'] = self.r_max
        if self.yml_path is not None:
            species_dict['yml_path'] = self.yml_path
        if self.is_ts:
            species_dict['ts_methods'] = self.ts_methods
            species_dict['ts_guesses'] = [tsg.as_dict() for tsg in self.ts_guesses]
            species_dict['ts_conf_spawned'] = self.ts_conf_spawned
            species_dict['ts_number'] = self.ts_number
            species_dict['ts_report'] = self.ts_report
            species_dict['rxn_label'] = self.rxn_label
            species_dict['successful_methods'] = self.successful_methods
            species_dict['unsuccessful_methods'] = self.unsuccessful_methods
            species_dict['chosen_ts_method'] = self.chosen_ts_method
            species_dict['chosen_ts'] = self.chosen_ts
        if self.run_time is not None:
            species_dict['run_time'] = self.run_time.total_seconds()
        species_dict['t1'] = self.t1
        species_dict['label'] = self.label
        species_dict['long_thermo_description'] = self.long_thermo_description
        species_dict['multiplicity'] = self.multiplicity
        if self.number_of_radicals is not None:
            species_dict['number_of_radicals'] = self.number_of_radicals
        species_dict['charge'] = self.charge
        species_dict['generate_thermo'] = self.generate_thermo
        if self.opt_level is not None:
            species_dict['opt_level'] = self.opt_level
        if self.final_xyz is not None:
            species_dict['final_xyz'] = self.final_xyz
        species_dict['number_of_rotors'] = self.number_of_rotors
        species_dict['rotors_dict'] = self.rotors_dict
        species_dict['external_symmetry'] = self.external_symmetry
        species_dict['optical_isomers'] = self.optical_isomers
        species_dict['neg_freqs_trshed'] = self.neg_freqs_trshed
        if self.bond_corrections is not None:
            species_dict['bond_corrections'] = self.bond_corrections
        if self.mol is not None:
            species_dict['mol'] = self.mol.toAdjacencyList()
        if self.initial_xyz is not None:
            species_dict['initial_xyz'] = self.initial_xyz
        if self.checkfile is not None:
            species_dict['checkfile'] = self.checkfile
        if self.conformer_checkfiles:
            species_dict['conformer_checkfiles'] = self.conformer_checkfiles
        if self.most_stable_conformer is not None:
            species_dict['most_stable_conformer'] = self.most_stable_conformer
        return species_dict

    def from_dict(self, species_dict):
        """
        A helper function for loading this object from a dictionary in a YAML file for restarting ARC
        """
        try:
            self.label = species_dict['label']
        except KeyError:
            raise InputError('All species must have a label')
        self.run_time = datetime.timedelta(seconds=species_dict['run_time']) if 'run_time' in species_dict else None
        self.t1 = species_dict['t1'] if 't1' in species_dict else None
        self.e_elect = species_dict['E electronic'] if 'E electronic' in species_dict else None
        self.arkane_file = species_dict['arkane_file'] if 'arkane_file' in species_dict else None
        self.yml_path = species_dict['yml_path'] if 'yml_path' in species_dict else None
        self.rxn_label = species_dict['rxn_label'] if 'rxn_label' in species_dict else None
        self.long_thermo_description = species_dict['long_thermo_description']\
            if 'long_thermo_description' in species_dict else ''
        self.initial_xyz = standardize_xyz_string(species_dict['initial_xyz']) if 'initial_xyz' in species_dict\
            else None
        self.final_xyz = standardize_xyz_string(species_dict['final_xyz']) if 'final_xyz' in species_dict else None
        if 'xyz' in species_dict and self.initial_xyz is None and self.final_xyz is None:
            self.process_xyz(species_dict['xyz'])
        self.r_min = species_dict['r_min'] if 'r_min' in species_dict else None
        self.r_max = species_dict['r_max'] if 'r_max' in species_dict else None
        self.is_ts = species_dict['is_ts'] if 'is_ts' in species_dict else False
        if self.is_ts:
            self.ts_conf_spawned = species_dict['ts_conf_spawned'] if 'ts_conf_spawned' in species_dict else False
            self.ts_number = species_dict['ts_number'] if 'ts_number' in species_dict else None
            self.ts_report = species_dict['ts_report'] if 'ts_report' in species_dict else ''
            ts_methods = species_dict['ts_methods'] if 'ts_methods' in species_dict else None
            if ts_methods is None:
                self.ts_methods = default_ts_methods
            elif isinstance(ts_methods, list):
                self.ts_methods = ts_methods
                if not self.ts_methods:
                    self.ts_methods = ['user guess']
            else:
                raise TSError('ts_methods must be a list, got {0} of type {1}'.format(ts_methods, type(ts_methods)))
            self.ts_guesses = [TSGuess(ts_dict=tsg) for tsg in species_dict['ts_guesses']]\
                if 'ts_guesses' in species_dict else list()
            self.successful_methods = species_dict['successful_methods']\
                if 'successful_methods' in species_dict else list()
            self.unsuccessful_methods = species_dict['unsuccessful_methods']\
                if 'unsuccessful_methods' in species_dict else list()
            self.chosen_ts_method = species_dict['chosen_ts_method'] if 'chosen_ts_method' in species_dict else None
            self.chosen_ts = species_dict['chosen_ts'] if 'chosen_ts' in species_dict else None
            self.checkfile = species_dict['checkfile'] if 'checkfile' in species_dict else None
            self.conformer_checkfiles = species_dict['conformer_checkfiles'] if 'conformer_checkfiles' in species_dict\
                else list()
            self.most_stable_conformer = species_dict['most_stable_conformer'] if 'most_stable_conformer'\
                                                                                  in species_dict else None
        else:
            self.ts_methods = None
        for char in self.label:
            if char not in valid_chars:
                raise SpeciesError('Species label {0} contains an invalid character: "{1}"'.format(self.label, char))
        try:
            self.multiplicity = species_dict['multiplicity']
        except KeyError:
            self.multiplicity = None
        try:
            self.charge = species_dict['charge']
        except KeyError:
            logger.debug('No charge specified for {0}, assuming charge 0.'.format(self.label))
            self.charge = 0
        if self.is_ts:
            self.generate_thermo = False
        else:
            self.generate_thermo = species_dict['generate_thermo'] if 'generate_thermo' in species_dict else True
        self.number_of_radicals = species_dict['number_of_radicals'] if 'number_of_radicals' in species_dict else None
        self.opt_level = species_dict['opt_level'] if 'opt_level' in species_dict else None
        self.number_of_rotors = species_dict['number_of_rotors'] if 'number_of_rotors' in species_dict else 0
        self.rotors_dict = species_dict['rotors_dict'] if 'rotors_dict' in species_dict else dict()
        self.external_symmetry = species_dict['external_symmetry'] if 'external_symmetry' in species_dict else None
        self.optical_isomers = species_dict['optical_isomers'] if 'optical_isomers' in species_dict else None
        self.neg_freqs_trshed = species_dict['neg_freqs_trshed'] if 'neg_freqs_trshed' in species_dict else list()
        self.bond_corrections = species_dict['bond_corrections'] if 'bond_corrections' in species_dict else dict()
        try:
            self.mol = Molecule().fromAdjacencyList(str(species_dict['mol'])) if 'mol' in species_dict else None
        except (ValueError, InvalidAdjacencyListError) as e:
            logger.error('Could not read RMG adjacency list {0}. Got:\n{1}'.format(species_dict['mol'] if 'mol'
                                                                                    in species_dict else None,
                                                                                    e.message))
            self.mol = None
        smiles = species_dict['smiles'] if 'smiles' in species_dict else None
        inchi = species_dict['inchi'] if 'inchi' in species_dict else None
        adjlist = species_dict['adjlist'] if 'adjlist' in species_dict else None
        if self.mol is None:
            if adjlist is not None:
                self.mol = Molecule().fromAdjacencyList(adjlist=adjlist)
            elif inchi is not None:
                self.mol = rmg_mol_from_inchi(inchi)
            elif smiles is not None:
                self.mol = Molecule(SMILES=smiles)
        if self.mol is None and not self.is_ts:
            xyz = self.final_xyz or self.initial_xyz
            if xyz:
                self.mol_from_xyz(xyz)
        if self.mol is not None:
            if 'bond_corrections' not in species_dict:
                self.bond_corrections = enumerate_bonds(self.mol)
                if self.bond_corrections:
                    self.long_thermo_description += 'Bond corrections: {0}\n'.format(self.bond_corrections)
            if self.multiplicity is None:
                self.multiplicity = self.mol.multiplicity
            if self.charge is None:
                self.charge = self.mol.getNetCharge()
            if self.mol_list is None:
                if not self.charge:
                    self.mol_list = self.mol.generate_resonance_structures(keep_isomorphic=False,
                                                                           filter_structures=True)
        if self.mol is None and self.initial_xyz is None and self.final_xyz is None and not self.conformers\
                and not any([tsg.xyz for tsg in self.ts_guesses]):
            # TS species are allowed to be loaded w/o a structure
            raise SpeciesError('Must have either mol or xyz for species {0}'.format(self.label))

    def from_yml_file(self, label=None):
        """
        Load important species attributes such as label and final_xyz from the Arkane YAML file
        Actual QM data parsing is done later when processing thermo and kinetics
        """
        rmg_spc = Species()
        arkane_spc = ArkaneSpecies(species=rmg_spc)
        # The data from the YAML file is loaded into the `species` argument of the `load_yaml` method in Arkane
        arkane_spc.load_yaml(path=self.yml_path, species=rmg_spc, pdep=False)
        self.label = label if label is not None else arkane_spc.label
        self.final_xyz = get_xyz_string(coord=arkane_spc.conformer.coordinates.value,
                                        number=arkane_spc.conformer.number.value)
        if arkane_spc.adjacency_list is not None:
            try:
                self.mol = Molecule().fromAdjacencyList(adjlist=arkane_spc.adjacency_list)
            except ValueError:
                print('Could not read adjlist:\n{0}'.format(arkane_spc.adjacency_list))  # should *not* be logging
                raise
        elif arkane_spc.inchi is not None:
            self.mol = Molecule().fromInChI(inchistr=arkane_spc.inchi)
        elif arkane_spc.smiles is not None:
            self.mol = Molecule().fromSMILES(arkane_spc.smiles)
        if self.mol is not None:
            self.mol_list = self.mol.generate_resonance_structures(keep_isomorphic=False, filter_structures=True)
            self.multiplicity = self.mol.multiplicity
            self.charge = self.mol.getNetCharge()
        if self.multiplicity is None:
            self.multiplicity = arkane_spc.conformer.spinMultiplicity
        if self.optical_isomers is None:
            self.optical_isomers = arkane_spc.conformer.opticalIsomers
        if self.external_symmetry is None:
            external_symmetry_mode = None
            for mode in arkane_spc.conformer.modes:
                if isinstance(mode, (NonlinearRotor, LinearRotor)):
                    external_symmetry_mode = mode
                    break
            if external_symmetry_mode is not None:
                self.external_symmetry = external_symmetry_mode.symmetry
        if self.initial_xyz is not None:
            self.mol_from_xyz()
        if self.e_elect is None:  # TODO: this is actually the E0, not e_elect! be consistent!
            self.e_elect = arkane_spc.conformer.E0.value_si * 0.001  # convert to kJ/mol

    def generate_conformers(self):
        """
        Generate conformers using RDKit and OpenBabel for all representative localized structures of each species
        """
        if not self.is_ts:
            if not self.charge:
                for mol in self.mol_list:
                    self.find_conformers(mol)
            else:
                self.find_conformers(self.mol)
            for xyz in self.xyzs:
                self.conformers.append(xyz)
                self.conformer_energies.append(None)  # a placeholder (lists are synced)
        else:
            # generate "conformers" from the results of the different TS guess methods, if successful
            tsg_index = 0
            self.successful_methods = list()
            self.unsuccessful_methods = list()
            for i, xyz in enumerate(self.conformers):
                # when defining a TS species with xyz, it is saved in self.conformers via self.process_xyz()
                # make TSGuess objects out of them if don't already exist
                for tsg in self.ts_guesses:
                    if xyz == tsg.xyz:
                        break
                else:
                    self.ts_guesses.append(TSGuess(method='user guess {0}'.format(i), xyz=xyz))
                    self.ts_guesses[-1].success = True
            self.conformers = list()
            for tsg in self.ts_guesses:
                if tsg.success:
                    self.conformers.append(tsg.xyz)
                    self.conformer_energies.append(None)  # a placeholder (lists are synced)
                    tsg.index = tsg_index
                    tsg_index += 1
                    self.successful_methods.append(tsg.method)
                else:
                    self.unsuccessful_methods.append(tsg.method)
            error = False
            message = '\nAll TS guesses for {0} terminated.'.format(self.label)
            if self.successful_methods and not self.unsuccessful_methods:
                message += '\n All methods were successful: {0}'.format(self.successful_methods)
            elif self.successful_methods:
                message += ' Successful methods: {0}'.format(self.successful_methods)
            elif self.yml_path is not None and self.final_xyz is not None:
                message += ' Geometry parsed from YAML file.'
            else:
                message += ' No method has converged!'
                error = True
            if self.unsuccessful_methods:
                message += ' Unsuccessful methods: {0}'.format(self.unsuccessful_methods)
            logger.info(message)
            if error:
                logger.error('No TS methods for {0} have converged!'.format(self.label))
            logger.info('\n')

    def find_conformers(self, mol, method='all'):
        """
        Generates conformers for `mol` which is an ``RMG.Molecule`` object using the method/s
        specified in `method`: 'rdkit', 'openbabel', or 'all'. result/s saved to self.xyzs
        """
        rdkit, opnbbl = False, False
        rd_xyzs, ob_xyzs = list(), list()
        if method == 'all':
            rdkit = True
            opnbbl = True
        elif method.lower() in ['rdkit', 'rdk']:
            rdkit = True
        elif method.lower() in ['ob', 'openbabel', 'opnbbl']:
            opnbbl = True
        if rdkit:
            rd_xyzs, rd_energies = list(), list()
            try:
                rd_xyzs, rd_energies = _get_possible_conformers_rdkit(mol)
            except ValueError as e:
                logger.warning('Could not generate RDkit conformers for {0}, failed with: {1}'.format(
                    self.label, e.message))
            if rd_xyzs:
                rd_xyz = get_min_energy_conformer(xyzs=rd_xyzs, energies=rd_energies)
                self.xyzs.append(get_xyz_string(coord=rd_xyz, mol=mol))
        if opnbbl:
            ob_xyzs, ob_energies = _get_possible_conformers_openbabel(mol)
            ob_xyz = get_min_energy_conformer(xyzs=ob_xyzs, energies=ob_energies)
            self.xyzs.append(get_xyz_string(coord=ob_xyz, mol=mol))
        logger.debug('Considering {actual} conformers for {label} out of {total} total ran using a force field'.format(
            actual=len(self.xyzs), total=len(rd_xyzs+ob_xyzs), label=self.label))

    def determine_rotors(self):
        """
        Determine possible unique rotors in the species to be treated as hindered rotors,
        taking into account all localized structures.
        The resulting rotors are saved in {'pivots': [1, 3], 'top': [3, 7], 'scan': [2, 1, 3, 7]} format
        in self.species_dict[species.label]['rotors_dict']. Also updates 'number_of_rotors'.
        """
        if not self.is_ts:
            if not self.charge:
                mol_list = self.mol_list
            else:
                mol_list = [self.mol]
            for mol in mol_list:
                rotors = find_internal_rotors(mol)
                for new_rotor in rotors:
                    for existing_rotor in self.rotors_dict.values():
                        if existing_rotor['pivots'] == new_rotor['pivots']:
                            break
                    else:
                        self.rotors_dict[self.number_of_rotors] = new_rotor
                        self.number_of_rotors += 1
            if self.number_of_rotors == 1:
                logger.info('\nFound one possible rotor for {0}'.format(self.label))
            elif self.number_of_rotors > 1:
                logger.info('\nFound {0} possible rotors for {1}'.format(self.number_of_rotors, self.label))
            if self.number_of_rotors > 0:
                logger.info('Pivot list(s) for {0}: {1}\n'.format(
                    self.label, [self.rotors_dict[i]['pivots'] for i in range(self.number_of_rotors)]))

    def set_dihedral(self, scan, pivots, deg_increment):
        """
        Generated an RDKit molecule object from the given self.final_xyz.
        Increments the current dihedral angle between atoms i, j, k, l in the `scan` list by 'deg_increment` in degrees.
        All bonded atoms are moved accordingly. The result is saved in self.initial_xyz.
        `pivots` is used to identify the rotor.
        """
        if deg_increment == 0:
            logger.warning('set_dihedral was called with zero increment for {label} with pivots {pivots}'
                            .format(label=self.label, pivots=pivots))
            for rotor in self.rotors_dict.values():  # penalize this rotor to avoid inf. looping
                if rotor['pivots'] == pivots:
                    rotor['times_dihedral_set'] += 1
                    break
        else:
            for rotor in self.rotors_dict.values():
                if rotor['pivots'] == pivots and rotor['times_dihedral_set'] <= 10:
                    rotor['times_dihedral_set'] += 1
                    break
            else:
                logger.info('\n\n')
                for i, rotor in self.rotors_dict.items():
                    logger.error('Rotor {i} with pivots {pivots} was set {times} times'.format(
                        i=i, pivots=rotor['pivots'], times=rotor['times_dihedral_set']))
                raise RotorError('Rotors for {0} were set beyond the maximal number of times without converging')
            for i, _ in enumerate(scan):
                scan[i] -= 1  # atom indices start from 0, but atom labels (as in scan) start from 1
            coordinates, atoms, _, _, _ = get_xyz_matrix(self.final_xyz)
            mol = molecules_from_xyz(self.final_xyz, multiplicity=self.multiplicity, charge=self.charge)[1]
            conf, rd_mol, indx_map = rdkit_conf_from_mol(mol, coordinates)
            rd_scan = [indx_map[scan[i]] for i in range(4)]  # convert the atom indices in `scan` to RDkit indices

            deg0 = rdMT.GetDihedralDeg(conf, rd_scan[0], rd_scan[1], rd_scan[2], rd_scan[3])  # get original dihedral
            deg = deg0 + deg_increment
            rdMT.SetDihedralDeg(conf, rd_scan[0], rd_scan[1], rd_scan[2], rd_scan[3], deg)
            new_xyz = list()
            for i in range(rd_mol.GetNumAtoms()):
                new_xyz.append([conf.GetAtomPosition(indx_map[i]).x, conf.GetAtomPosition(indx_map[i]).y,
                                conf.GetAtomPosition(indx_map[i]).z])
            self.initial_xyz = get_xyz_string(new_xyz, symbol=atoms)

    def determine_symmetry(self):
        """
        Determine external symmetry and chirality (optical isomers) of the species
        """
        xyz = self.final_xyz or self.initial_xyz
        atom_numbers = list()  # List of atomic numbers
        coordinates, symbols, _, _, _ = get_xyz_matrix(xyz)
        for symbol in symbols:
            atom_numbers.append(getElement(str(symbol)).number)
        coordinates = np.array(coordinates, np.float64)  # N x 3 numpy.ndarray of atomic coordinates
        #  in the same order as `atom_numbers`
        unique_id = '0'  # Just some name that the SYMMETRY code gives to one of its jobs
        scr_dir = os.path.join(arc_path, str('scratch'))  # Scratch directory that the SYMMETRY code writes its files in
        if not os.path.exists(scr_dir):
            os.makedirs(scr_dir)
        symmetry = optical_isomers = 1
        qmdata = QMData(
            groundStateDegeneracy=1,  # Only needed to check if valid QMData
            numberOfAtoms=len(atom_numbers),
            atomicNumbers=atom_numbers,
            atomCoords=(coordinates, str('angstrom')),
            energy=(0.0, str('kcal/mol'))  # Only needed to avoid error
        )
        settings = type(str(''), (), dict(symmetryPath=str('symmetry'), scratchDirectory=scr_dir))()
        pgc = PointGroupCalculator(settings, unique_id, qmdata)
        pg = pgc.calculate()
        if pg is not None:
            symmetry = pg.symmetryNumber
            optical_isomers = 2 if pg.chiral else optical_isomers
        self.optical_isomers = self.optical_isomers if self.optical_isomers is not None else optical_isomers
        if self.optical_isomers != optical_isomers:
            logger.warning("User input of optical isomers for {0} and ARC's calculation differ: {1} and {2},"
                            " respectively. Using the user input of {1}"
                            .format(self.label, self.optical_isomers, optical_isomers))
        self.external_symmetry = self.external_symmetry if self.external_symmetry is not None else symmetry
        if self.external_symmetry != symmetry:
            logger.warning("User input of external symmetry for {0} and ARC's calculation differ: {1} and {2},"
                            " respectively. Using the user input of {1}"
                            .format(self.label, self.external_symmetry, symmetry))

    def determine_multiplicity(self, smiles, adjlist, mol):
        """
        Determine the spin multiplicity of the species
        """
        if mol is not None and mol.multiplicity >= 1:
            self.multiplicity = mol.multiplicity
        elif adjlist:
            mol = Molecule().fromAdjacencyList(str(adjlist))
            self.multiplicity = mol.multiplicity
        elif self.mol is not None and self.mol.multiplicity >= 1:
            self.multiplicity = self.mol.multiplicity
        elif smiles:
            mol = Molecule(SMILES=str(smiles))
            self.multiplicity = mol.multiplicity
        else:
            xyz = self.final_xyz or self.initial_xyz
            if xyz is None and len(self.conformers):
                xyz = self.conformers[0]
            if xyz:
                atoms = get_xyz_matrix(xyz)[1]
                electrons = 0
                for atom in atoms:
                    for number, symbol in symbol_by_number.items():
                        if symbol == atom:
                            electrons += number
                            break
                    else:
                        raise SpeciesError('Could not identify atom symbol {0}'.format(atom))
                if electrons % 2 == 1:
                    self.multiplicity = 2
                    logger.warning('Assuming a multiplicity of 2 for species {0}'.format(self.label))
                else:
                    self.multiplicity = 1
                    logger.warning('Assuming a multiplicity of 1 for species {0}'.format(self.label))
        if self.multiplicity is None:
            raise SpeciesError('Could not determine multiplicity for species {0}'.format(self.label))

    def make_ts_report(self):
        """A helper function to write content into the .ts_report attribute"""
        self.ts_report = ''
        if self.chosen_ts_method is not None:
            self.ts_report += 'TS method summary for {0} in {1}\n'.format(self.label, self.rxn_label)
            self.ts_report += 'Methods that successfully generated a TS guess:\n'
            if self.successful_methods:
                for successful_method in self.successful_methods:
                    self.ts_report += successful_method + ','
            if self.unsuccessful_methods:
                self.ts_report += '\nMethods that were unsuccessfully in generating a TS guess:\n'
                for unsuccessful_method in self.unsuccessful_methods:
                    self.ts_report += unsuccessful_method + ','
            self.ts_report += '\nThe method that generated the best TS guess and its output used for the' \
                              ' optimization: {0}'.format(self.chosen_ts_method)

    def mol_from_xyz(self, xyz=None):
        """
        Make sure atom order in self.mol corresponds to xyz
        Important for TS discovery and for identifying rotor indices

        This works by generating a molecule from the xyz and using the
        2D structure to confirm that the perceived molecule is correct.
        Resonance structures are generated and saved to ``self.mol_list``.
        """
        if xyz is None:
            xyz = self.final_xyz or self.initial_xyz or self.conformers[0]

        if self.mol is not None:
            # self.mol should have come from another source, e.g. SMILES or yml
            original_mol = self.mol
            self.mol = molecules_from_xyz(xyz, multiplicity=self.multiplicity, charge=self.charge)[1]

            if self.mol is not None and not check_isomorphism(original_mol, self.mol):
                raise InputError('XYZ and the 2D graph representation of the Molecule are not isomorphic.\n'
                                 'Got xyz:\n{0}\n\nwhich corresponds to {1}\n{2}\n\nand: {3}\n{4}'.format(
                                  xyz, self.mol.toSMILES(), self.mol.toAdjacencyList(),
                                  original_mol.toSMILES(), original_mol.toAdjacencyList()))
            if self.mol is None:
                self.mol = original_mol  # todo: Atom order will not be correct, need fix
        else:
            self.mol = molecules_from_xyz(xyz, multiplicity=self.multiplicity, charge=self.charge)[1]

        if self.mol_list is None and self.mol is not None:
            # Assign atom ids first, so they carry through to the resonance structures
            self.mol.assignAtomIDs()
            # The generate_resonance_structures method changes atom order
            # Make a copy so we don't disturb the original order from xyz
            self.mol_list = self.mol.copy(deep=True).generate_resonance_structures(keep_isomorphic=False,
                                                                                   filter_structures=True)
        order_atoms_in_mol_list(ref_mol=self.mol, mol_list=self.mol_list)

    def process_conformers_file(self, conformers_path):
        """
        Populate the conformers and conformer energies lists with data from an ARC's conformers file.
        The `conformers_path` should direct to either a "conformers_before_optimization" or
        a "conformers_after_optimization" ARC file.
        """
        if not os.path.isfile(conformers_path):
            raise ValueError('Conformers file {0} could not be found'.format(conformers_path))
        with open(conformers_path, 'r') as f:
            lines = f.readlines()
        conformer = ''
        first_conformer = True  # to keep conformers and conformer_energies lists the same length we need to
        # differentiate between starting the first conformer and the starting other conformers
        # if energy wasn't read and this isn't the first conformer, append None to conformer_energies
        read_energy = False
        for line in lines:
            if 'conformer' in line or 'SMILES' in line or 'Failed to converge' in line or line in ['\r', '\n', '\r\n']:
                continue_reading_conformer = False
            elif 'Relative Energy' in line:
                self.conformer_energies.append(float(line.split()[2]) * 1000)  # convert kJ/mol to J/mol
                continue_reading_conformer = False
                read_energy = True
            else:
                if not first_conformer and conformer == '':
                    if not read_energy:
                        self.conformer_energies.append(None)  # dummy (lists should be the same length)
                first_conformer = False
                read_energy = False
                conformer += line
                continue_reading_conformer = True
            if not continue_reading_conformer and conformer:
                self.conformers.append(standardize_xyz_string(conformer))
                conformer = ''

    def process_xyz(self, xyz_list):
        """
        Treat `xyz_list` as a list if it is not already one.
        `xyz_list` list entries could be any mixture of a multiline xyz string format, xyz file,
        a path to an ARC conformers file (either with or without energies), or a path to an ESS log/input file.
        Populate self.conformers
        """
        if xyz_list is not None:
            if not isinstance(xyz_list, list):
                xyz_list = [xyz_list]
            for xyz in xyz_list:
                if not isinstance(xyz, (str, unicode)):
                    raise InputError('each xyz entry in xyz_list must be a string. Got:\n{0}\nwhich is a {1}'.format(
                        xyz, type(xyz)))
                if os.path.isfile(xyz):
                    file_extension = os.path.splitext(xyz)[1]
                    if 'txt' in file_extension:
                        # assume his is an ARC conformer file
                        self.process_conformers_file(conformers_path=xyz)
                    else:
                        # assume this is an ESS log file
                        self.conformers.append(parse_xyz_from_file(xyz))  # also calls standardize_xyz_string()
                        self.conformer_energies.append(None)  # dummy (lists should be the same length)
                else:
                    # assume this is a string format xyz
                    self.conformers.append(standardize_xyz_string(xyz))
                    self.conformer_energies.append(None)  # dummy (lists should be the same length)

    def set_transport_data(self, lj_path, opt_path, bath_gas, opt_level, freq_path='', freq_level=None):
        """
        Set the species.transport_data attribute after a Lennard-Jones calculation (via OneDMin)
        `lj_path` is the path to a oneDMin job output file
        `opt_path` is the path to an opt job output file
        `bath_gas` is the oneDMin job bath gas
        `opt_level` is the optimization level of theory
        """
        original_comment = self.transport_data.comment
        comment = 'L-J coefficients calculated by OneDMin using a DF-MP2/aug-cc-pVDZ potential energy surface ' \
                  'with {0} as the bath gas'.format(bath_gas)
        epsilon, sigma = None, None
        with open(lj_path, 'r') as f:
            lines = f.readlines()
        for line in lines:
            if 'Epsilons[1/cm]' in line:
                # Conversion of cm^-1 to J/mol (see https://cccbdb.nist.gov/wavenumber.asp)
                epsilon = (float(line.split()[-1]) * 11.96266, str('J/mol'))
            elif 'Sigmas[angstrom]' in line:
                # Convert Angstroms to meters
                sigma = (float(line.split()[-1]) * 1e-10, str('m'))
        if self.number_of_atoms == 1:
            shape_index = 0
            comment += '; The molecule is monoatomic'
        else:
            coordinates = get_xyz_matrix(self.final_xyz or self.initial_xyz or self.conformers[0])[0]
            coordinates = np.array(coordinates)
            if is_linear(coordinates):
                shape_index = 1
                comment += '; The molecule is linear'
            else:
                shape_index = 2
        if self.number_of_atoms > 1:
            dipole_moment = parse_dipole_moment(opt_path) or 0
            if dipole_moment:
                comment += '; Dipole moment was calculated at the {0} level of theory'.format(opt_level)
        else:
            dipole_moment = 0
        polar = self.transport_data.polarizability or (0, str('angstroms^3'))
        if freq_path:
            polar = (parse_polarizability(freq_path), str('angstroms^3'))
            comment += '; Polarizability was calculated at the {0} level of theory'.format(freq_level)
        comment += '; Rotational Relaxation Collision Number was not determined, default value is 2'
        if original_comment:
            comment += '; ' + original_comment
        self.transport_data = TransportData(
            shapeIndex=shape_index,
            epsilon=epsilon,
            sigma=sigma,
            dipoleMoment=(dipole_moment, str('De')),
            polarizability=polar,
            rotrelaxcollnum=2,  # rotational relaxation collision number at 298 K
            comment=str(comment)
        )

    def determine_radius(self):
        """
        Determine the largest distance from the coordinate system origin attributed to one of the molecule's
        atoms in 3D space.

        Returns:
            float: The species radius.
        """
        conf = self.conformers[0] if self.conformers else None
        xyz = self.final_xyz or self.initial_xyz or conf
        if xyz is None:
            raise SpeciesError('Could not determine species {0} radius without xyz'.format(self.label))
        cm_x, cm_y, cm_z = get_center_of_mass(xyz)
        _, symbols, x, y, z = get_xyz_matrix(xyz)
        x = [xi - cm_x for xi in x]
        y = [yi - cm_y for yi in y]
        z = [zi - cm_z for zi in z]
        border_elements = list()  # a list of the farthest element/s
        r = 0
        for si, xi, yi, zi in zip(symbols, x, y, z):
            ri = xi ** 2 + yi ** 2 + zi ** 2
            if ri == r:
                border_elements.append(si)
            elif ri > r:
                r = ri
                border_elements = [si]
        atom_r = max([get_atom_radius(si) if get_atom_radius(si) is not None else 1.50 for si in border_elements])
        radius = r ** 0.5 + atom_r
        logger.debug('Using a radius of {0} to represent species {1} in a OneDMin calculation'.format(
            radius, self.label))
        return radius

    def determine_onedmin_radii(self, bath_gas):
        """
        Determine r_min and r_max for the OneDMin scan. Assumes that the species' shape is close to a sphere.

        Args:
            bath_gas (str, unicode): The collider bath gas.
        """
        if self.r_min is None or self.r_max is None:
            if bath_gas not in ['He', 'Ne', 'Ar', 'Kr', 'H2', 'N2', 'O2']:
                raise SpeciesError('Unknown bath gas. Should be either He, Ne, Ar, Kr, H2, N2, or O2, '
                                   'got {0}'.format(bath_gas))
            bath_gas_radius_dict = {'He': get_atom_radius('He'), 'Ne': get_atom_radius('Ne'),
                                    'Ar': get_atom_radius('Ar'), 'Kr': get_atom_radius('Kr'),
                                    'H2': 0.743 * 0.5 + get_atom_radius('H'), 'N2': 1.1 * 0.5 + get_atom_radius('N'),
                                    'O2': 1.208 * 0.5 + get_atom_radius('O')}  # Angstrom
            bath_gas_r = bath_gas_radius_dict[bath_gas]
            species_radius = self.determine_radius()
            self.r_min = round(species_radius + bath_gas_r, 2)
            self.r_max = self.r_min + 3.0
            logger.info('Using r_min = {0} and r_max = {1} for the OneDMin calculation of species {2}'.format(
                self.r_min, self.r_max, self.label))


class TSGuess(object):
    """
    TSGuess class

    The user can define xyz directly, and the default `method` will be 'User guess'
    Alternatively, either ARC or the user can provide reactant/s and product/s geometries with a specified `method`
    `method` could be one of the following:
    - QST2
    - DEGSM
    - NEB
    - Kinbot: requires the RMG family, only works for H,C,O,S
    - AutoTST

    ====================== ============= ===============================================================================
    Attribute              Type          Description
    ====================== ============= ===============================================================================
    `xyz`                   ``str``      The 3D guess
    `method`                ``str''      The method/source used for the xyz guess
    `reactants_xyz`         ``list``     A list of tuples, each containing:
                                           (reactant label, reactant geometry in string format)
    `products_xyz`          ``list``     A list of tuples, each containing:
                                           (product label, product geometry in string format)
    `family`                ``str``      The RMG family that corresponds to the reaction, if applicable
    `rmg_reaction`          ``Reaction`` The RMG Reaction
    `t0'                    ``float``    Initial time of spawning the guess job
    `execution_time`        ``str``      Overall execution time for species
    `success`               ``bool``     Whether the TS guess method succeeded in generating an XYZ guess or not
    `energy`                ``float``    Relative energy of all TS conformers
    `index`                 ``int``      An index corresponding to the conformer jobs spawned for each TSGuess object
                                           Assigned only if self.success is ``True``
    ====================== ============= ===============================================================================

    """
    def __init__(self, method=None, reactants_xyz=None, products_xyz=None, family=None, xyz=None,
                 rmg_reaction=None, ts_dict=None):

        if ts_dict is not None:
            # Reading from a dictionary
            self.from_dict(ts_dict=ts_dict)
        else:
            # Not reading from a dictionary
            self.t0 = None
            self.index = None
            self.execution_time = None
            self.xyz = None
            self.process_xyz(xyz)  # populates self.xyz
            self.success = None
            self.energy = None
            self.method = method.lower() if method is not None else 'user guess'
            if 'user guess' in self.method:
                if self.xyz is None:
                    raise TSError('If no method is specified, an xyz guess must be given')
                self.success = True
                self.execution_time = 0
            self.reactants_xyz = reactants_xyz if reactants_xyz is not None else list()
            self.products_xyz = products_xyz if products_xyz is not None else list()
            self.rmg_reaction = rmg_reaction
            self.family = family
            # if self.family is None and self.method.lower() in ['kinbot', 'autotst']:
            #     raise TSError('No family specified for method {0}'.format(self.method))
        if not ('user guess' in self.method or 'autotst' in self.method
                or self.method in ['user guess'] + [tsm.lower() for tsm in default_ts_methods]):
            raise TSError('Unrecognized method. Should be either {0}. Got: {1}'.format(
                          ['User guess'] + default_ts_methods, self.method))

    def as_dict(self):
        """A helper function for dumping this object as a dictionary in a YAML file for restarting ARC"""
        ts_dict = dict()
        ts_dict['t0'] = self.t0
        ts_dict['method'] = self.method
        ts_dict['success'] = self.success
        ts_dict['energy'] = self.energy
        ts_dict['index'] = self.index
        ts_dict['execution_time'] = self.execution_time
        if self.xyz:
            ts_dict['xyz'] = self.xyz
        if self.reactants_xyz:
            ts_dict['reactants_xyz'] = self.reactants_xyz
        if self.products_xyz:
            ts_dict['products_xyz'] = self.products_xyz
        if self.family is not None:
            ts_dict['family'] = self.family
        if self.rmg_reaction is not None:
            rxn_string = ' <=> '.join([' + '.join([spc.molecule[0].toSMILES() for spc in self.rmg_reaction.reactants]),
                                      ' + '.join([spc.molecule[0].toSMILES() for spc in self.rmg_reaction.products])])
            ts_dict['rmg_reaction'] = rxn_string
        return ts_dict

    def from_dict(self, ts_dict):
        """
        A helper function for loading this object from a dictionary in a YAML file for restarting ARC
        """
        self.t0 = ts_dict['t0'] if 't0' in ts_dict else None
        self.index = ts_dict['index'] if 'index' in ts_dict else None
        self.xyz = ts_dict['xyz'] if 'xyz' in ts_dict else None
        self.process_xyz(self.xyz)  # re-populates self.xyz
        self.success = ts_dict['success'] if 'success' in ts_dict else None
        self.energy = ts_dict['energy'] if 'energy' in ts_dict else None
        self.execution_time = ts_dict['execution_time'] if 'execution_time' in ts_dict else None
        self.method = ts_dict['method'].lower() if 'method' in ts_dict else 'user guess'
        if 'user guess' in self.method:
            if self.xyz is None:
                raise TSError('If no method is specified, an xyz guess must be given')
            self.success = self.success if self.success is not None else True
            self.execution_time = '0'
        self.reactants_xyz = ts_dict['reactants_xyz'] if 'reactants_xyz' in ts_dict else list()
        self.products_xyz = ts_dict['products_xyz'] if 'products_xyz' in ts_dict else list()
        self.family = ts_dict['family'] if 'family' in ts_dict else None
        if self.family is None and self.method.lower() in ['kinbot', 'autotst']:
            # raise TSError('No family specified for method {0}'.format(self.method))
            logger.warning('No family specified for method {0}'.format(self.method))
        if 'rmg_reaction' not in ts_dict:
            self.rmg_reaction = None
        else:
            rxn_string = ts_dict['rmg_reaction']
            plus = ' + '
            arrow = ' <=> '
            if arrow not in rxn_string:
                raise TSError('Could not read the reaction string. Expected to find " <=> ". '
                              'Got: {0}'.format(rxn_string))
            sides = rxn_string.split(arrow)
            reac = sides[0]
            prod = sides[1]
            if plus in reac:
                reac = reac.split(plus)
            else:
                reac = [reac]
            if plus in prod:
                prod = prod.split(plus)
            else:
                prod = [prod]
            reactants = list()
            products = list()
            for reactant in reac:
                reactants.append(Species().fromSMILES(str(reactant)))
            for product in prod:
                products.append(Species().fromSMILES(str(product)))
            self.rmg_reaction = Reaction(reactants=reactants, products=products)

    def execute_ts_guess_method(self):
        """
        Execute a TS guess method
        """
        if self.method == 'user guess':
            pass
        elif self.method == 'qst2':
            self.qst2()
        elif self.method == 'degsm':
            self.degsm()
        elif self.method == 'neb':
            self.neb()
        elif self.method == 'kinbot':
            self.kinbot()
        elif self.method == 'autotst':
            self.autotst()
        else:
            raise TSError('Unrecognized method. Should be either {0}. Got: {1}'.format(
                          ['User guess'] + default_ts_methods, self.method))

    def autotst(self):
        """
        Determine a TS guess using AutoTST for the following RMG families:
        Current supported families are:
        - H_Abstraction
        Near-future supported families might be:
        - Disproportionation
        - R_Addition_MultipleBond
        - intra_H_migration
        """
        if not isinstance(self.rmg_reaction, Reaction):
            raise InputError('AutoTST requires an RMG Reaction object. Got: {0}'.format(type(self.rmg_reaction)))
        if self.family not in ['H_Abstraction']:
            logger.debug('AutoTST currently only works for H_Abstraction. Got: {0}'.format(self.family))
            self.xyz = ''
        else:
            self.xyz = atst.autotst(rmg_reaction=self.rmg_reaction, reaction_family=self.family)

    def qst2(self):
        """
        Determine a TS guess using QST2
        """
        self.success = False

    def degsm(self):
        """
        Determine a TS guess using DEGSM
        """
        self.success = False

    def neb(self):
        """
        Determine a TS guess using NEB
        """
        self.success = False

    def kinbot(self):
        """
        Determine a TS guess using Kinbot for RMG's unimolecular families
        """
        self.success = False

    def process_xyz(self, xyz):
        """
        If xyz represents a file path, parse it.
        Standardize the xyz format using converter.standardize_xyz_string
        """
        if xyz is not None:
            if os.path.isfile(xyz):
                xyz = parse_xyz_from_file(xyz)
            self.xyz = standardize_xyz_string(xyz)


def _get_possible_conformers_rdkit(mol):
    """
    A helper function for conformer search
    Uses rdkit to automatically generate a set of len(mol.atoms)-3)*30 initial geometries, optimizes
    these geometries using MMFF94s, calculates the energies using MMFF94s
    and converts them back in terms of the RMG atom ordering
    Returns the coordinates and energies
    """
    if not isinstance(mol, (Molecule, RDMol)):
        raise SpeciesError('Can generate conformers to either an RDKit or RMG molecule. Got {0}'.format(type(mol)))
    rd_indx_map = dict()
    if isinstance(mol, RDMol):
        rd_mol = mol
    else:
        rd_mol, rd_inds = mol.toRDKitMol(removeHs=False, returnMapping=True)

        for k, atom in enumerate(mol.atoms):
            ind = rd_inds[atom]
            rd_indx_map[ind] = k
    if len(mol.atoms) > 50:
        Chem.AllChem.EmbedMultipleConfs(rd_mol, numConfs=500, randomSeed=1)
    elif len(mol.atoms) > 5:
        Chem.AllChem.EmbedMultipleConfs(rd_mol, numConfs=len(mol.atoms) * 3, randomSeed=1)
    else:
        Chem.AllChem.EmbedMultipleConfs(rd_mol, numConfs=50, randomSeed=1)
    energies = []
    xyzs = []
    for i in range(rd_mol.GetNumConformers()):
        v = 1
        while v == 1:
            v = Chem.AllChem.MMFFOptimizeMolecule(rd_mol, mmffVariant=str('MMFF94s'), confId=i,
                                                  maxIters=500, ignoreInterfragInteractions=False)
        mp = Chem.AllChem.MMFFGetMoleculeProperties(rd_mol, mmffVariant=str('MMFF94s'))
        if mp is not None:
            ff = Chem.AllChem.MMFFGetMoleculeForceField(rd_mol, mp, confId=i)
            energies.append(ff.CalcEnergy())
            cf = rd_mol.GetConformer(i)
            xyz = []
            for j in range(cf.GetNumAtoms()):
                pt = cf.GetAtomPosition(j)
                xyz.append([pt.x, pt.y, pt.z])
            if isinstance(mol, Molecule):
                xyz = [xyz[rd_indx_map[j]] for j, _ in enumerate(xyz)]  # reorder
            xyzs.append(xyz)
    return xyzs, energies


def _get_possible_conformers_openbabel(mol):
    """
    A helper function for conformer search
    Uses OpenBabel to automatically generate set of len(mol.atoms)*10-3 initial geometries,
    optimizes these geometries using MMFF94s, calculates the energies using MMFF94s
    Returns the coordinates and energies
    """
    energies = []
    xyzs = []
    obmol, _ = toOBMol(mol, returnMapping=True)
    pybmol = pyb.Molecule(obmol)
    pybmol.make3D()
    obmol = pybmol.OBMol

    ff = ob.OBForceField.FindForceField("mmff94s")
    ff.Setup(obmol)
    if len(mol.atoms) > 50:
        ff.WeightedRotorSearch(500, 2000)
    elif len(mol.atoms) > 5:
        ff.WeightedRotorSearch(len(mol.atoms) * 10 - 3, 2000)
    else:
        ff.WeightedRotorSearch(50, 2000)
    ff.GetConformers(obmol)
    for n in range(obmol.NumConformers()):
        xyz = []
        obmol.SetConformer(n)
        ff.Setup(obmol)
        # ff.ConjugateGradientsTakeNSteps(1000)
        energies.append(ff.Energy())
        for atm in pybmol.atoms:
            xyz.append(list(atm.coords))
        xyzs.append(xyz)
    return xyzs, energies


def get_min_energy_conformer(xyzs, energies):
    """Get the minimum energy for conformers"""
    minval = min(energies)
    minind = energies.index(minval)
    return xyzs[minind]


def find_internal_rotors(mol):
    """
    Locates the sets of indices corresponding to every internal rotor.
    Returns for each rotors the gaussian scan coordinates, the pivots and the top.
    """
    rotors = []
    for atom1 in mol.vertices:
        if atom1.isNonHydrogen():
            for atom2, bond in atom1.edges.items():
                if atom2.isNonHydrogen() and mol.vertices.index(atom1) < mol.vertices.index(atom2) \
                        and (bond.isSingle() or bond.isHydrogenBond()) and not mol.isBondInCycle(bond):
                    if len(atom1.edges) > 1 and len(atom2.edges) > 1:  # none of the pivotal atoms are terminal
                        rotor = dict()
                        # pivots:
                        rotor['pivots'] = [mol.vertices.index(atom1) + 1, mol.vertices.index(atom2) + 1]
                        # top:
                        top1, top2 = [], []
                        top1_has_heavy_atoms, top2_has_heavy_atoms = False, False
                        explored_atom_list = [atom2]
                        atom_list_to_explore = [atom1]
                        while len(atom_list_to_explore):
                            for atom in atom_list_to_explore:
                                top1.append(mol.vertices.index(atom) + 1)
                                for atom3, _ in atom.edges.items():
                                    if atom3.isHydrogen():
                                        # append H w/o further exploring
                                        top1.append(mol.vertices.index(atom3) + 1)
                                    elif atom3 not in explored_atom_list:
                                        top1_has_heavy_atoms = True
                                        atom_list_to_explore.append(atom3)  # explore it further
                                atom_list_to_explore.pop(atom_list_to_explore.index(atom))
                                explored_atom_list.append(atom)  # mark as explored
                        explored_atom_list, atom_list_to_explore = [atom1, atom2], [atom2]
                        while len(atom_list_to_explore):
                            for atom in atom_list_to_explore:
                                top2.append(mol.vertices.index(atom) + 1)
                                for atom3, _ in atom.edges.items():
                                    if atom3.isHydrogen():
                                        # append H w/o further exploring
                                        top2.append(mol.vertices.index(atom3) + 1)
                                    elif atom3 not in explored_atom_list:
                                        top2_has_heavy_atoms = True
                                        atom_list_to_explore.append(atom3)  # explore it further
                                atom_list_to_explore.pop(atom_list_to_explore.index(atom))
                                explored_atom_list.append(atom)  # mark as explored
                        if top1_has_heavy_atoms and not top2_has_heavy_atoms:
                            rotor['top'] = top2
                        elif top2_has_heavy_atoms and not top1_has_heavy_atoms:
                            rotor['top'] = top1
                        else:
                            rotor['top'] = top1 if len(top1) <= len(top2) else top2
                        # scan:
                        rotor['scan'] = []
                        heavy_atoms = []
                        hydrogens = []
                        for atom3, _ in atom1.edges.items():
                            if atom3.isHydrogen():
                                hydrogens.append(mol.vertices.index(atom3))
                            elif atom3 is not atom2:
                                heavy_atoms.append(mol.vertices.index(atom3))
                        smallest_index = len(mol.vertices)
                        if len(heavy_atoms):
                            for i in heavy_atoms:
                                if i < smallest_index:
                                    smallest_index = i
                        else:
                            for i in hydrogens:
                                if i < smallest_index:
                                    smallest_index = i
                        rotor['scan'].append(smallest_index + 1)
                        rotor['scan'].extend([mol.vertices.index(atom1) + 1, mol.vertices.index(atom2) + 1])
                        heavy_atoms = []
                        hydrogens = []
                        for atom3, _ in atom2.edges.items():
                            if atom3.isHydrogen():
                                hydrogens.append(mol.vertices.index(atom3))
                            elif atom3 is not atom1:
                                heavy_atoms.append(mol.vertices.index(atom3))
                        smallest_index = len(mol.vertices)
                        if len(heavy_atoms):
                            for i in heavy_atoms:
                                if i < smallest_index:
                                    smallest_index = i
                        else:
                            for i in hydrogens:
                                if i < smallest_index:
                                    smallest_index = i
                        rotor['scan'].append(smallest_index + 1)
                        rotor['success'] = None
                        rotor['invalidation_reason'] = ''
                        rotor['times_dihedral_set'] = 0
                        rotor['scan_path'] = ''
                        rotors.append(rotor)
    return rotors


def determine_occ(label, xyz, charge):
    """
    Determines the number of occupied orbitals for an MRCI calculation
    """
    electrons = 0
    for line in xyz.split('\n'):
        if line:
            atom = Atom(element=str(line.split()[0]))
            electrons += atom.number
    electrons -= charge


def nearly_equal(a, b, sig_fig=5):
    """
    A helper function to determine whether two floats are nearly equal.
    Can be replaced by math.isclose in Py3
    """
    return a == b or int(a*10**sig_fig) == int(b*10**sig_fig)


def determine_rotor_symmetry(rotor_path, label, pivots):
    """
    Determine the rotor symmetry number from the potential scan given in :list:`energies` in J/mol units
    Assumes the list represents a 360 degree scan
    str:`label` is the species name, used for logging and error messages
    list:`pivots` are the rotor's pivots, used for logging and error messages
    The *worst* resolution for each peak and valley is determined.
    The first criterion for a symmetric rotor is that the highest peak and the lowest peak must be within the
    worst peak resolution (and the same is checked for valleys).
    A second criterion for a symmetric rotor is that the highest and lowest peaks must be within 10% of
    the highest peak value. This is only applied if the highest peak is above 2 kJ/mol.
    """
    log = determine_qm_software(fullpath=rotor_path)
    energies, _ = log.loadScanEnergies()

    symmetry = None
    max_e = max(energies)
    if max_e > 2000:
        tol = 0.10 * max_e  # tolerance for the second criterion
    else:
        tol = max_e
    min_e = energies[0]
    for i, e in enumerate(energies):
        # sometimes the opt level and scan levels mismatch, causing the minimum to be close to 0 degrees, but not at 0
        if e < min_e:
            min_e = e
    peaks, valleys = list(), list()  # the peaks and valleys of the scan
    worst_peak_resolution, worst_valley_resolution = 0, 0
    for i, e in enumerate(energies):
        # identify peaks and valleys, and determine worst resolutions in the scan
        ip1 = cyclic_index_i_plus_1(i, len(energies))  # i Plus 1
        im1 = cyclic_index_i_minus_1(i)                # i Minus 1
        if i == 0 and energies[im1] == e:
            # If the first and last scan points have same energy, change im1
            im1 -= 1
            logger.debug('im1: {0}, ip1: {1}, em1: {2}, e: {3}, ep1: {4}'.format(
                im1, ip1, energies[im1], e, energies[ip1]))
        if e > energies[im1] and e > energies[ip1]:
            # this is a local peak
            if any([diff > worst_peak_resolution for diff in [e - energies[im1], e - energies[ip1]]]):
                worst_peak_resolution = max(e - energies[im1], e - energies[ip1])
            peaks.append(e)
        elif e < energies[im1] and e < energies[ip1]:
            # this is a local valley
            if any([diff > worst_valley_resolution for diff in [energies[im1] - e, energies[ip1] - e]]):
                worst_valley_resolution = max(energies[im1] - e, energies[ip1] - e)
            valleys.append(e)
    # The number of peaks and valley must always be the same (what goes up must come down), if it isn't then there's
    # something seriously wrong with the scan
    if len(peaks) != len(valleys):
        logger.error('Rotor of species {0} between pivots {1} does not have the same number'
                     ' of peaks ({2}) and valleys ({3}).'.format(label, pivots, len(peaks), len(valleys)))
        return len(peaks), max_e * 0.001  # this works for CC(=O)[O]
    min_peak = min(peaks)
    max_peak = max(peaks)
    min_valley = min(valleys)
    max_valley = max(valleys)
    # Criterion 1: worst resolution
    if max_peak - min_peak > worst_peak_resolution:
        # The rotor cannot be symmetric
        symmetry = 1
        reason = 'worst peak resolution criterion'
    elif max_valley - min_valley > worst_valley_resolution:
        # The rotor cannot be symmetric
        symmetry = 1
        reason = 'worst valley resolution criterion'
    # Criterion 2: 10% * max_peak
    elif max_peak - min_peak > tol:
        # The rotor cannot be symmetric
        symmetry = 1
        reason = '10% of the maximum peak criterion'
    else:
        # We declare this rotor as symmetric and the symmetry number is the number of peaks (and valleys)
        symmetry = len(peaks)
        reason = 'number of peaks and valleys, all within the determined resolution criteria'
    if symmetry not in [1, 2, 3]:
        logger.info('Determined symmetry number {0} for rotor of species {1} between pivots {2};'
                    ' you should make sure this makes sense'.format(symmetry, label, pivots))
    else:
        logger.info('Determined a symmetry number of {0} for rotor of species {1} between pivots {2}'
                    ' based on the {3}.'.format(symmetry, label, pivots, reason))
    return symmetry, max_e * 0.001  # max_e in kJ/mol


def cyclic_index_i_plus_1(i, length):
    """A helper function for cyclic indexing rotor scans"""
    return i + 1 if i + 1 < length else 0


def cyclic_index_i_minus_1(i):
    """A helper function for cyclic indexing rotor scans"""
    return i - 1 if i - 1 > 0 else -1


def determine_rotor_type(rotor_path):
    """
    Determine whether this rotor should be treated as a HinderedRotor of a FreeRotor
    according to it's maximum peak
    """
    log = determine_qm_software(fullpath=rotor_path)
    energies, _ = log.loadScanEnergies()
    max_val = max(energies) * 0.001  # convert to kJ/mol (Arkane used SI)
    return 'FreeRotor' if max_val < minimum_barrier else 'HinderedRotor'


def enumerate_bonds(mol):
    """
    A helper function for calling Molecule.enumerate_bonds
    First, get the Kekulized molecule (get the Kekule version with alternating single and double bonds if the molecule
    is aromatic), since we don't have implementation for aromatic bond additivity corrections
    """
    mol_list = generate_kekule_structure(mol)
    if mol_list:
        return mol_list[0].enumerate_bonds()
    else:
        return mol.enumerate_bonds()
