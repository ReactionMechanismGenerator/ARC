#!/usr/bin/env python
# encoding: utf-8

from __future__ import (absolute_import, division, print_function, unicode_literals)
import os
import logging
import numpy as np
import datetime

from rdkit import Chem
from rdkit.Chem import rdMolTransforms as rdmt
from rdkit.Chem.rdchem import EditableMol as RDMol
import openbabel as ob
import pybel as pyb

from arkane.common import ArkaneSpecies, symbol_by_number
from arkane.statmech import Log
from rmgpy.molecule.converter import toOBMol
from rmgpy.molecule.element import getElement
from rmgpy.molecule.molecule import Atom, Molecule
from rmgpy.qm.qmdata import QMData
from rmgpy.qm.symmetry import PointGroupCalculator
from rmgpy.reaction import Reaction
from rmgpy.species import Species
from rmgpy.statmech import NonlinearRotor, LinearRotor

from arc.arc_exceptions import SpeciesError, RotorError, InputError, TSError
from arc.settings import arc_path, default_ts_methods, valid_chars, minimum_barrier
from arc.parser import parse_xyz_from_file
from arc.species.converter import get_xyz_string, get_xyz_matrix, rdkit_conf_from_mol, standardize_xyz_string,\
    molecules_from_xyz, rmg_mol_from_inchi, order_atoms_in_mol_list, check_isomorphism
from arc.ts import atst

##################################################################


class ARCSpecies(object):
    """
    ARCSpecies class

    ====================== ============= ===============================================================================
    Attribute              Type          Description
    ====================== ============= ===============================================================================
    `label`                 ``str``      The species' label
    `multiplicity`          ``int``      The species' multiplicity. Can be determined from adjlist/smiles/xyz
                                           The algorithm assumes it's either a singlet or a doublet
    `charge`                ``int''      The species' net charge. Assumed to be 0 be default.
    `e0`                    ``float``    The total electronic energy E0 of the species at the chosen sp level (kJ/mol)
    `is_ts`                 ``bool``     Whether or not the species represents a transition state
    `number_of_rotors`      ``int``      The number of potential rotors to scan
    `rotors_dict`           ``dict``     A dictionary of rotors. structure given below.
    `conformers`            ``list``     A list of selected conformers XYZs
    `conformer_energies`    ``list``     A list of conformers E0 (Hartree)
    `initial_xyz`           ``string``   The initial geometry guess
    `final_xyz`             ``string``   The optimized species geometry
    `opt_level`             ``string``   Level of theory for geometry optimization. Saved for archiving.
    `number_of_atoms`       ``int``      The number of atoms in the species/TS
    `mol`                   ``Molecule`` An RMG:`Molecule` object used for BAC determination.
                                           Atom order corresponds to the order in .initial_xyz
    `mol_list`              ``list``     A list of localized structures generated from 'mol', if possible
    `rmg_species`           ``Species``  An RMG Species object to be converted to an ARCSpecies object
    `bond_corrections`      ``dict``     The bond additivity corrections (BAC) to be used. Determined from the structure
                                           if not directly given.
    `run_time`              ``timedelta`` Overall species execution time
    `t1`                    ``float``    The T1 diagnostic parameter from Molpro
    `neg_freqs_trshed`      ``list``     A list of negative frequencies this species was troubleshooted for
    `generate_thermo`       ``bool``     Whether ot not to calculate thermodynamic properties for this species
    `thermo`                ``HeatCapacityModel``  The thermodata calculated by ARC
    `rmg_thermo`            ``HeatCapacityModel``  The thermodata generated by RMG for comparison
    `long_thermo_description`  ``str``   A description for the species entry in the thermo library outputed
    `ts_methods`            ``list``     Methods to try for generating TS guesses. If Species is a TS and `ts_methods`
                                           is an empty list, then xyz (user guess) must be given.
                                           If `ts_methods` is None, it will be set to the default methods
    `ts_guesses`            ``list``     A list of TSGuess objects for each of the specified methods
    `successful_methods`    ``list``     Methods used to generate a TS guess that successfully generated an XYZ guess
    `unsuccessful_methods`  ``list``     Methods used to generate a TS guess that were unsuccessfully
    `chosen_ts`             ``int``      The TSGuess index corresponding to the chosen TS conformer used for optimization
    `chosen_ts_method`      ``str``      The TS method that was actually used for optimization
    `ts_conf_spawned`       ``bool``     Whether conformers were already spawned for the Species (representing a TS)
                                           based on its TSGuess objects
    `ts_number`             ``int``      An auto-generated number associating the TS ARCSpecies object with the
                                           corresponding ARCReaction object
    `ts_report`             ``str``      A description of all methods used for guessing a TS and their ranking
    `rxn_label`             ``str``      The reaction string (relevant for TSs)
    `arkane_file`           ``str``      Path to the Arkane Species file generated in Processor
    `yml_path`              ``str``      Path to an Arkane YAML file representing a species (for loading the object)
    `external_symmetry`     ``int``      The external symmetry of the species (not including rotor symmetries)
    `optical_isomers`       ``int``      Whether (=2) or not (=1) the species has chiral center/s
    ====================== ============= ===============================================================================

    Dictionary structure:

*   rotors_dict: {1: {'pivots': pivots_list,
                      'top': top_list,
                      'scan': scan_list,
                      'success': ``bool``.
                      'invalidation_reason': ``str``,
                      'times_dihedral_set': ``int``,
                      'scan_path': <path to scan output file>},
                      'max_e': ``float``,  # in kJ/mol
                      'symmetry': ``int``,
                  2: {}, ...
                 }
    """
    def __init__(self, is_ts=False, rmg_species=None, mol=None, label=None, xyz=None, multiplicity=None, charge=None,
                 smiles='', adjlist='', inchi='', bond_corrections=None, generate_thermo=True, species_dict=None,
                 yml_path=None, ts_methods=None, ts_number=None, rxn_label=None, external_symmetry=None,
                 optical_isomers=None, run_time=None):
        self.t1 = None
        self.ts_number = ts_number
        self.conformers = list()
        self.conformer_energies = list()
        self.xyzs = list()  # used for conformer search
        self.thermo = None
        self.rmg_thermo = None
        self.rmg_kinetics = None
        self.number_of_atoms = None
        self.mol = mol
        self.mol_list = None
        self.multiplicity = multiplicity
        self.external_symmetry = external_symmetry
        self.optical_isomers = optical_isomers
        self.charge = charge
        self.run_time = run_time

        if species_dict is not None:
            # Reading from a dictionary
            self.from_dict(species_dict=species_dict)
        else:
            # Not reading from a dictionary
            self.is_ts = is_ts
            self.ts_conf_spawned = False
            self.e0 = None
            self.arkane_file = None
            if self.is_ts:
                if ts_methods is None:
                    self.ts_methods = default_ts_methods
                elif isinstance(ts_methods, list):
                    self.ts_methods = ts_methods
                    if not self.ts_methods:
                        self.ts_methods = ['user guess']
                else:
                    raise TSError('ts_methods must be a list, got {0} of type {1}'.format(ts_methods, type(ts_methods)))
            else:
                self.ts_methods = None
            self.rxn_label = rxn_label
            self.ts_guesses = list()
            self.successful_methods = list()
            self.unsuccessful_methods = list()
            self.chosen_ts_method = None
            self.chosen_ts = None
            self.generate_thermo = generate_thermo if not self.is_ts else False
            self.long_thermo_description = ''
            self.opt_level = ''
            self.ts_report = ''
            self.yml_path = yml_path
            self.final_xyz = ''
            self.number_of_rotors = 0
            self.rotors_dict = dict()
            self.rmg_species = rmg_species
            self.initial_xyz = check_species_xyz(xyz)
            if bond_corrections is None:
                self.bond_corrections = dict()
            else:
                self.bond_corrections = bond_corrections

            if self.yml_path is not None:
                # a YAML path was given
                self.from_yml_file(label)
                if label is not None:
                    self.label = label
            elif self.rmg_species is not None:
                # an RMG Species was given
                if not isinstance(self.rmg_species, Species):
                    raise SpeciesError('The rmg_species parameter has to be a valid RMG Species object.'
                                       ' Got: {0}'.format(type(self.rmg_species)))
                if not self.rmg_species.molecule:
                    raise SpeciesError('If an RMG Species given, it must have a non-empty molecule list')
                if not self.rmg_species.label and not label:
                    raise SpeciesError('If an RMG Species given, it must have a label or a label must be given'
                                       ' separately')
                if label:
                    self.label = label
                else:
                    self.label = self.rmg_species.label
                self.mol_list = self.rmg_species.molecule
                if self.mol is None:
                    self.mol = self.rmg_species.molecule[0]
                    if len(self.rmg_species.molecule) == 1:
                        self.mol_list = self.rmg_species.generate_resonance_structures(
                            keep_isomorphic=False, filter_structures=True)
                    self.mol_list = self.rmg_species.molecule
                    logging.info('Using localized structure {0} of species {1} for BAC determination. To use a'
                                 ' different  structure, pass the RMG:Molecule object in the `mol` parameter'.format(
                                    self.mol.toSMILES(), self.label))
                self.multiplicity = self.rmg_species.molecule[0].multiplicity
                self.charge = self.rmg_species.molecule[0].getNetCharge()
            else:
                # parameters were entered directly, not via an RMG:Species object
                self.label = label
                if self.mol is None:
                    if adjlist:
                        self.mol = Molecule().fromAdjacencyList(adjlist=adjlist)
                    elif inchi:
                        self.mol = rmg_mol_from_inchi(inchi)
                    elif smiles:
                        self.mol = Molecule(SMILES=smiles)
                if not self.is_ts and self.mol is None and self.generate_thermo:
                    logging.warn('No structure (SMILES, adjList, RMG:Species, or RMG:Molecule) was given for species'
                                 ' {0}, NOT using bond additivity corrections (BAC) for thermo computation.'.format(
                        self.label))
                self.multiplicity = multiplicity
                self.charge = charge

            if not self.is_ts:
                # Perceive molecule from xyz coordinates
                # This also populates mol_list
                if self.final_xyz or self.initial_xyz:
                    self.mol_from_xyz()
                # Generate bond list for applying bond corrections
                if not self.bond_corrections:
                    self.bond_corrections = self.mol.enumerate_bonds()
                    if self.bond_corrections:
                        self.long_thermo_description += 'Bond corrections: {0}\n'.format(self.bond_corrections)

            if self.mol is not None:
                self.number_of_atoms = len(self.mol.atoms)
                if self.mol_list is None:
                    mol_copy = self.mol.copy(deep=True)
                    self.mol_list = mol_copy.generate_resonance_structures(keep_isomorphic=False, filter_structures=True)
            elif not self.bond_corrections and self.generate_thermo:
                logging.warn('Cannot determine bond additivity corrections (BAC) for species {0} based on xyz'
                             ' coordinates only. For better thermoproperties, provide bond corrections.')

            if self.initial_xyz is not None:
                # consider the initial guess as one of the conformers if generating others.
                # otherwise, just consider it as the conformer.
                self.conformers.append(self.initial_xyz)
                self.conformer_energies.append(0.0)  # dummy

            self.neg_freqs_trshed = list()

        if self.multiplicity is None:
            self.determine_multiplicity(smiles, adjlist, self.mol)
            logging.debug('No multiplicity specified for {0}, assuming {1}.'.format(self.label, self.multiplicity))
        if self.charge is None:
            logging.debug('No charge specified for {0}, assuming charge 0.'.format(self.label))
            self.charge = 0
        if self.multiplicity is not None and self.multiplicity < 1:
            raise SpeciesError('Multiplicity for species {0} is lower than 1. Got: {1}'.format(
                self.label, multiplicity))
        if not isinstance(self.multiplicity, int) and self.multiplicity is not None:
            raise SpeciesError('Multiplicity for species {0} is not an integer. Got: {1}, a {2}'.format(
                self.label, self.multiplicity, type(self.multiplicity)))
        if not isinstance(self.charge, int):
            raise SpeciesError('Charge for species {0} is not an integer (got {1}, a {2})'.format(
                self.label, self.charge, type(self.charge)))
        if not self.is_ts and self.initial_xyz is None and self.mol is None:
            raise SpeciesError('No structure (xyz, SMILES, adjList, RMG:Species, or RMG:Molecule) was given for'
                               ' species {0}'.format(self.label))
        if self.label is None :
            raise SpeciesError('A label must be specified for an ARCSpecies object.')
        # Check that `label` is valid, since it is used for folder names
        for char in self.label:
            if char not in valid_chars:
                raise SpeciesError('Species label {0} contains an invalid character: "{1}"'.format(self.label, char))

    def as_dict(self):
        """A helper function for dumping this object as a dictionary in a YAML file for restarting ARC"""
        species_dict = dict()
        species_dict['is_ts'] = self.is_ts
        species_dict['E0'] = self.e0
        species_dict['arkane_file'] = self.arkane_file
        if self.yml_path is not None:
            species_dict['yml_path'] = self.yml_path
        if self.is_ts:
            species_dict['ts_methods'] = self.ts_methods
            species_dict['ts_guesses'] = [tsg.as_dict() for tsg in self.ts_guesses]
            species_dict['ts_conf_spawned'] = self.ts_conf_spawned
            species_dict['ts_number'] = self.ts_number
            species_dict['ts_report'] = self.ts_report
            species_dict['rxn_label'] = self.rxn_label
            species_dict['successful_methods'] = self.successful_methods
            species_dict['unsuccessful_methods'] = self.unsuccessful_methods
            species_dict['chosen_ts_method'] = self.chosen_ts_method
            species_dict['chosen_ts'] = self.chosen_ts
        if self.run_time is not None:
            species_dict['run_time'] = self.run_time.total_seconds()
        species_dict['t1'] = self.t1
        species_dict['label'] = self.label
        species_dict['long_thermo_description'] = self.long_thermo_description
        species_dict['multiplicity'] = self.multiplicity
        species_dict['charge'] = self.charge
        species_dict['generate_thermo'] = self.generate_thermo
        species_dict['opt_level'] = self.opt_level
        species_dict['final_xyz'] = self.final_xyz
        species_dict['number_of_rotors'] = self.number_of_rotors
        species_dict['rotors_dict'] = self.rotors_dict
        species_dict['external_symmetry'] = self.external_symmetry
        species_dict['optical_isomers'] = self.optical_isomers
        species_dict['neg_freqs_trshed'] = self.neg_freqs_trshed
        if self.bond_corrections is not None:
            species_dict['bond_corrections'] = self.bond_corrections
        if self.mol is not None:
            species_dict['mol'] = self.mol.toAdjacencyList()
        if self.initial_xyz is not None:
            species_dict['initial_xyz'] = self.initial_xyz
        return species_dict

    def from_dict(self, species_dict):
        """
        A helper function for loading this object from a dictionary in a YAML file for restarting ARC
        """
        try:
            self.label = species_dict['label']
        except KeyError:
            raise InputError('All species must have a label')
        self.run_time = datetime.timedelta(seconds=species_dict['run_time']) if 'run_time' in species_dict else None
        self.t1 = species_dict['t1'] if 't1' in species_dict else None
        self.e0 = species_dict['E0'] if 'E0' in species_dict else None
        self.arkane_file = species_dict['arkane_file'] if 'arkane_file' in species_dict else None
        self.yml_path = species_dict['yml_path'] if 'yml_path' in species_dict else None
        self.rxn_label = species_dict['rxn_label'] if 'rxn_label' in species_dict else None
        self.long_thermo_description = species_dict['long_thermo_description']\
            if 'long_thermo_description' in species_dict else ''
        self.initial_xyz = check_species_xyz(species_dict['initial_xyz']) if 'initial_xyz' in species_dict else None
        self.final_xyz = check_species_xyz(species_dict['final_xyz']) if 'final_xyz' in species_dict else ''
        if 'xyz' in species_dict and self.initial_xyz is None and not self.final_xyz:
            self.initial_xyz = check_species_xyz(species_dict['xyz'])
        self.is_ts = species_dict['is_ts'] if 'is_ts' in species_dict else False
        if self.is_ts:
            self.ts_conf_spawned = species_dict['ts_conf_spawned'] if 'ts_conf_spawned' in species_dict else False
            self.ts_number = species_dict['ts_number'] if 'ts_number' in species_dict else None
            self.ts_report = species_dict['ts_report'] if 'ts_report' in species_dict else ''
            ts_methods = species_dict['ts_methods'] if 'ts_methods' in species_dict else None
            if ts_methods is None:
                self.ts_methods = default_ts_methods
            elif isinstance(ts_methods, list):
                self.ts_methods = ts_methods
                if not self.ts_methods:
                    self.ts_methods = ['user guess']
            else:
                raise TSError('ts_methods must be a list, got {0} of type {1}'.format(ts_methods, type(ts_methods)))
            self.ts_guesses = [TSGuess(ts_dict=tsg) for tsg in species_dict['ts_guesses']]\
                if 'ts_guesses' in species_dict else list()
            self.successful_methods = species_dict['successful_methods']\
                if 'successful_methods' in species_dict else list()
            self.unsuccessful_methods = species_dict['unsuccessful_methods']\
                if 'unsuccessful_methods' in species_dict else list()
            self.chosen_ts_method = species_dict['chosen_ts_method'] if 'chosen_ts_method' in species_dict else None
            self.chosen_ts = species_dict['chosen_ts'] if 'chosen_ts' in species_dict else None
        else:
            self.ts_methods = None
        for char in self.label:
            if char not in valid_chars:
                raise SpeciesError('Species label {0} contains an invalid character: "{1}"'.format(self.label, char))
        try:
            self.multiplicity = species_dict['multiplicity']
        except KeyError:
            self.multiplicity = None
        try:
            self.charge = species_dict['charge']
        except KeyError:
            logging.debug('No charge specified for {0}, assuming charge 0.'.format(self.label))
            self.charge = 0
        if self.is_ts:
            self.generate_thermo = False
        else:
            self.generate_thermo = species_dict['generate_thermo'] if 'generate_thermo' in species_dict else True
        self.opt_level = species_dict['opt_level'] if 'opt_level' in species_dict else ''
        self.number_of_rotors = species_dict['number_of_rotors'] if 'number_of_rotors' in species_dict else 0
        self.rotors_dict = species_dict['rotors_dict'] if 'rotors_dict' in species_dict else dict()
        self.external_symmetry = species_dict['external_symmetry'] if 'external_symmetry' in species_dict else None
        self.optical_isomers = species_dict['optical_isomers'] if 'optical_isomers' in species_dict else None
        self.neg_freqs_trshed = species_dict['neg_freqs_trshed'] if 'neg_freqs_trshed' in species_dict else list()
        self.bond_corrections = species_dict['bond_corrections'] if 'bond_corrections' in species_dict else dict()
        self.mol = Molecule().fromAdjacencyList(str(species_dict['mol'])) if 'mol' in species_dict else None
        smiles = species_dict['smiles'] if 'smiles' in species_dict else None
        inchi = species_dict['inchi'] if 'inchi' in species_dict else None
        adjlist = species_dict['adjlist'] if 'adjlist' in species_dict else None
        if self.mol is None:
            if adjlist is not None:
                self.mol = Molecule().fromAdjacencyList(adjlist=adjlist)
            elif inchi is not None:
                self.mol = rmg_mol_from_inchi(inchi)
            elif smiles is not None:
                self.mol = Molecule(SMILES=smiles)
        if self.mol is None and not self.is_ts:
            xyz = self.final_xyz or self.initial_xyz
            if xyz:
                self.mol_from_xyz(xyz)
        if self.mol is not None:
            if 'bond_corrections' not in species_dict:
                self.bond_corrections = self.mol.enumerate_bonds()
                if self.bond_corrections:
                    self.long_thermo_description += 'Bond corrections: {0}\n'.format(self.bond_corrections)
            self.number_of_atoms = len(self.mol.atoms)
            if self.multiplicity is None:
                self.multiplicity = self.mol.multiplicity
            if self.charge is None:
                self.charge = self.mol.getNetCharge()
            if self.mol_list is None:
                self.mol_list = self.mol.generate_resonance_structures(keep_isomorphic=False, filter_structures=True)
        if self.mol is None and self.initial_xyz is None and not self.final_xyz:
            raise SpeciesError('Must have either mol or xyz for species {0}'.format(self.label))
        if self.initial_xyz is not None and not self.final_xyz:
            # consider the initial guess as one of the conformers if generating others.
            # otherwise, just consider it as the conformer.
            self.conformers.append(self.initial_xyz)
            self.conformer_energies.append(0.0)  # dummy

    def from_yml_file(self, label=None):
        """
        Load important species attributes such as label and final_xyz from the Arkane YAML file
        Actual QM data parsing is done later when processing thermo and kinetics
        """
        rmg_spc = Species()
        arkane_spc = ArkaneSpecies(species=rmg_spc)
        # The data from the YAML file is loaded into the `species` argument of the `load_yaml` method in Arkane
        arkane_spc.load_yaml(path=self.yml_path, species=rmg_spc, pdep=False)
        self.label = label if label is not None else arkane_spc.label
        self.final_xyz = get_xyz_string(xyz=arkane_spc.conformer.coordinates.value,
                                        number=arkane_spc.conformer.number.value)
        if arkane_spc.adjacency_list is not None:
            try:
                self.mol = Molecule().fromAdjacencyList(adjlist=arkane_spc.adjacency_list)
            except ValueError as e:
                print('Could not read adjlist:\n{0}'.format(arkane_spc.adjacency_list))  # should *not* be logging
                raise e
        elif arkane_spc.inchi is not None:
            self.mol = Molecule().fromInChI(inchistr=arkane_spc.inchi)
        elif arkane_spc.smiles is not None:
            self.mol = Molecule().fromSMILES(arkane_spc.smiles)
        if self.mol is not None:
            self.mol_list = self.mol.generate_resonance_structures(keep_isomorphic=False, filter_structures=True)
            self.multiplicity = self.mol.multiplicity
            self.charge = self.mol.getNetCharge()
        if self.multiplicity is None:
            self.multiplicity = arkane_spc.conformer.spinMultiplicity
        if self.optical_isomers is None:
            self.optical_isomers = arkane_spc.conformer.opticalIsomers
        if self.external_symmetry is None:
            external_symmetry_mode = None
            for mode in arkane_spc.conformer.modes:
                if isinstance(mode, (NonlinearRotor, LinearRotor)):
                    external_symmetry_mode = mode
                    break
            if external_symmetry_mode is not None:
                self.external_symmetry = external_symmetry_mode.symmetry
        if self.initial_xyz is not None:
            self.mol_from_xyz()
        if self.e0 is None:
            self.e0 = arkane_spc.conformer.E0.value_si * 0.001  # convert to kJ/mol

    def generate_conformers(self):
        """
        Generate conformers using RDKit and OpenBabel for all representative localized structures of each species
        """
        if not self.is_ts:
            for mol in self.mol_list:
                self.find_conformers(mol)
            for xyz in self.xyzs:
                self.conformers.append(xyz)
                self.conformer_energies.append(0.0)  # a placeholder (lists are synced)
        else:
            # generate "conformers" from the results of the different TS guess methods, if successful
            tsg_index = 0
            self.successful_methods = list()
            self.unsuccessful_methods = list()
            for tsg in self.ts_guesses:
                if tsg.success:
                    self.conformers.append(tsg.xyz)
                    self.conformer_energies.append(0.0)  # a placeholder (lists are synced)
                    tsg.index = tsg_index
                    tsg_index += 1
                    self.successful_methods.append(tsg.method)
                else:
                    self.unsuccessful_methods.append(tsg.method)
            error = False
            message = '\nAll TS guesses for {0} terminated.'.format(self.label)
            if self.successful_methods and not self.unsuccessful_methods:
                message += '\n All methods were successful: {0}'.format(self.successful_methods)
            elif self.successful_methods:
                message += ' Successful methods: {0}'.format(self.successful_methods)
            elif self.yml_path is not None and self.final_xyz:
                message += ' Geometry parsed from YAML file.'
            else:
                message += ' No method has converged!'
                error = True
            if self.unsuccessful_methods:
                message += ' Unsuccessful methods: {0}'.format(self.unsuccessful_methods)
            logging.info(message)
            if error:
                logging.error('No TS methods for {0} have converged!'.format(self.label))
            logging.info('\n')

    def find_conformers(self, mol, method='all'):
        """
        Generates conformers for `mol` which is an ``RMG.Molecule`` object using the method/s
        specified in `method`: 'rdkit', 'openbabel', or 'all'. result/s saved to self.xyzs
        """
        rdkit, opnbbl = False, False
        rd_xyzs, ob_xyzs = list(), list()
        if method == 'all':
            rdkit = True
            opnbbl = True
        elif method.lower() in ['rdkit', 'rdk']:
            rdkit = True
        elif method.lower() in ['ob', 'openbabel', 'opnbbl']:
            opnbbl = True
        if rdkit:
            rd_xyzs, rd_energies = list(), list()
            try:
                rd_xyzs, rd_energies = _get_possible_conformers_rdkit(mol)
            except ValueError as e:
                logging.warn('Could not generate RDkit conformers for {0}, failed with: {1}'.format(
                    self.label, e.message))
            if rd_xyzs:
                rd_xyz = get_min_energy_conformer(xyzs=rd_xyzs, energies=rd_energies)
                self.xyzs.append(get_xyz_string(xyz=rd_xyz, mol=mol))
        if opnbbl:
            ob_xyzs, ob_energies = _get_possible_conformers_openbabel(mol)
            ob_xyz = get_min_energy_conformer(xyzs=ob_xyzs, energies=ob_energies)
            self.xyzs.append(get_xyz_string(xyz=ob_xyz, mol=mol))
        logging.debug('Considering {actual} conformers for {label} out of {total} total ran using a force field'.format(
            actual=len(self.xyzs), total=len(rd_xyzs+ob_xyzs), label=self.label))

    def determine_rotors(self):
        """
        Determine possible unique rotors in the species to be treated as hindered rotors,
        taking into account all localized structures.
        The resulting rotors are saved in {'pivots': [1, 3], 'top': [3, 7], 'scan': [2, 1, 3, 7]} format
        in self.species_dict[species.label]['rotors_dict']. Also updates 'number_of_rotors'.
        """
        if not self.is_ts:
            for mol in self.mol_list:
                rotors = find_internal_rotors(mol)
                for new_rotor in rotors:
                    for existing_rotor in self.rotors_dict.values():
                        if existing_rotor['pivots'] == new_rotor['pivots']:
                            break
                    else:
                        self.rotors_dict[self.number_of_rotors] = new_rotor
                        self.number_of_rotors += 1
            if self.number_of_rotors == 1:
                logging.info('\nFound one possible rotor for {0}'.format(self.label))
            elif self.number_of_rotors > 1:
                logging.info('\nFound {0} possible rotors for {1}'.format(self.number_of_rotors, self.label))
            if self.number_of_rotors > 0:
                logging.info('Pivot list(s) for {0}: {1}\n'.format(self.label,
                                                    [self.rotors_dict[i]['pivots'] for i in range(self.number_of_rotors)]))

    def set_dihedral(self, scan, pivots, deg_increment):
        """
        Generated an RDKit molecule object from the given self.final_xyz.
        Increments the current dihedral angle between atoms i, j, k, l in the `scan` list by 'deg_increment` in degrees.
        All bonded atoms are moved accordingly. The result is saved in self.initial_xyz.
        `pivots` is used to identify the rotor.
        """
        if deg_increment == 0:
            logging.warning('set_dihedral was called with zero increment for {label} with pivots {pivots}'.format(
                label=self.label, pivots=pivots))
            for rotor in self.rotors_dict.values():  # penalize this rotor to avoid inf. looping
                if rotor['pivots'] == pivots:
                    rotor['times_dihedral_set'] += 1
                    break
        else:
            for rotor in self.rotors_dict.values():
                if rotor['pivots'] == pivots and rotor['times_dihedral_set'] <= 10:
                    rotor['times_dihedral_set'] += 1
                    break
            else:
                logging.info('\n\n')
                for i, rotor in self.rotors_dict.items():
                    logging.error('Rotor {i} with pivots {pivots} was set {times} times'.format(
                        i=i, pivots=rotor['pivots'], times=rotor['times_dihedral_set']))
                raise RotorError('Rotors for {0} were set beyond the maximal number of times without converging')
            for i, _ in enumerate(scan):
                scan[i] -= 1  # atom indices start from 0, but atom labels (as in scan) start from 1
            coordinates, atoms, _, _, _ = get_xyz_matrix(self.final_xyz)
            _, mol = molecules_from_xyz(self.final_xyz)
            conf, rd_mol, indx_map = rdkit_conf_from_mol(mol, coordinates)
            rd_scan = [indx_map[scan[i]] for i in range(4)]  # convert the atom indices in `scan` to RDkit indices

            deg0 = rdmt.GetDihedralDeg(conf, rd_scan[0], rd_scan[1], rd_scan[2], rd_scan[3])  # get the original dihedral
            deg = deg0 + deg_increment
            rdmt.SetDihedralDeg(conf, rd_scan[0], rd_scan[1], rd_scan[2], rd_scan[3], deg)
            new_xyz = list()
            for i in range(rd_mol.GetNumAtoms()):
                new_xyz.append([conf.GetAtomPosition(indx_map[i]).x, conf.GetAtomPosition(indx_map[i]).y,
                            conf.GetAtomPosition(indx_map[i]).z])
            self.initial_xyz = get_xyz_string(new_xyz, symbol=atoms)

    def determine_symmetry(self):
        """
        Determine external symmetry and optical isomers
        """
        xyz = self.final_xyz if self.final_xyz is not None else self.initial_xyz
        atom_numbers = list()  # List of atomic numbers
        coordinates = list()
        for line in xyz.split('\n'):
            if line:
                atom_numbers.append(getElement(str(line.split()[0])).number)
                coordinates.append([float(line.split()[1]), float(line.split()[2]), float(line.split()[3])])
        coordinates = np.array(coordinates, np.float64)  # N x 3 numpy.ndarray of atomic coordinates
        #  in the same order as `atom_numbers`
        unique_id = '0'  # Just some name that the SYMMETRY code gives to one of its jobs
        scr_dir = os.path.join(arc_path, str('scratch'))  # Scratch directory that the SYMMETRY code writes its files in
        if not os.path.exists(scr_dir):
            os.makedirs(scr_dir)
        symmetry = optical_isomers = 1
        qmdata = QMData(
            groundStateDegeneracy=1,  # Only needed to check if valid QMData
            numberOfAtoms=len(atom_numbers),
            atomicNumbers=atom_numbers,
            atomCoords=(coordinates, str('angstrom')),
            energy=(0.0, str('kcal/mol'))  # Only needed to avoid error
        )
        settings = type(str(''), (), dict(symmetryPath=str('symmetry'), scratchDirectory=scr_dir))()  # Creates anonymous class
        pgc = PointGroupCalculator(settings, unique_id, qmdata)
        pg = pgc.calculate()
        if pg is not None:
            symmetry = pg.symmetryNumber
            optical_isomers = 2 if pg.chiral else optical_isomers
        self.optical_isomers = self.optical_isomers if self.optical_isomers is not None else optical_isomers
        if self.optical_isomers != optical_isomers:
            logging.warn("User input of optical isomers for {0} and ARC's calculation differ: {1} and {2},"
                         " respectively. Using the user input of {1}".format(
                self.label, self.optical_isomers, optical_isomers))
        self.external_symmetry = self.external_symmetry if self.external_symmetry is not None else symmetry
        if self.external_symmetry != symmetry:
            logging.warn("User input of external symmetry for {0} and ARC's calculation differ: {1} and {2},"
                         " respectively. Using the user input of {1}".format(
                self.label, self.external_symmetry, symmetry))

    def determine_multiplicity(self, smiles, adjlist, mol):
        if mol:
            self.multiplicity = mol.multiplicity
        elif adjlist:
            mol = Molecule().fromAdjacencyList(adjlist)
            self.multiplicity = mol.multiplicity
        elif self.mol is not None and self.mol.multiplicity >= 1:
            self.multiplicity = self.mol.multiplicity
        elif smiles:
            mol = Molecule(SMILES=smiles)
            self.multiplicity = mol.multiplicity
        elif self.initial_xyz:
            _, atoms, _, _, _ = get_xyz_matrix(self.initial_xyz)
            electrons = 0
            for atom in atoms:
                for number, symbol in symbol_by_number.items():
                    if symbol == atom:
                        electrons += number
                        break
                else:
                    raise SpeciesError('Could not identify atom symbol {0}'.format(atom))
            if electrons % 2 == 1:
                self.multiplicity = 2
            else:
                self.multiplicity = 1
        if self.multiplicity is None:
            raise SpeciesError('Could not determine multiplicity for species {0}'.format(self.label))

    def is_linear(self):
        """
        A helper function for determination of the species linearity from the .final_xyz attribute
        """
        epsilon = 0.001
        if self.number_of_atoms == 1:
            return False
        if self.number_of_atoms == 2:
            return True
        if self.final_xyz:
            xyz = self.final_xyz
        else:
            xyz = self.initial_xyz
        if not xyz:
            raise SpeciesError('Cannot determine linearity for {0} without the initial/final xyz coordinates'.format(
                self.label))
        _, _, x, y, z = get_xyz_matrix(xyz)
        # first check whether the problem can be reduced into two (or one) dimensions
        reduced_coord = ''
        if all([nearly_equal(element, x[0]) for element in x]):
            reduced_coord += 'x'
        if all([nearly_equal(element, y[0]) for element in y]):
            reduced_coord += 'y'
        if all([nearly_equal(element, z[0]) for element in z]):
            reduced_coord += 'z'
        if reduced_coord:
            # The problem can (and should) be reduced to two dimensions.
            # (might actually be buggy to deal with it in 3D due to divisions by zero)
            # Use linear interpolation instead of a 3D line
            # This is often the case for standard orientation of linear molecules
            if len(reduced_coord) == 2:
                # This is the trivial case where all atoms are on the same axis by definition
                return True
            if reduced_coord == 'x':
                # don't use x
                x = y
                y = z
            elif reduced_coord == 'y':
                # keep x as it is, don't use y
                y = z
            elif reduced_coord == 'z':
                # keep x, y as they are, don't use z
                pass
            else:
                raise SpeciesError('Could not determine whether species {0} is linear, something must be wrong with its'
                                   ' coordinates:\n{1}'.format(self.label, xyz))
            for i, _ in enumerate(x):
                # Use a linear interpolation/extrapolation method, and compare extrapolated value and actual value
                if i > 1:  # only start the algorithm at the third atom (index 2)
                    if x[0] != x[1]:
                        y0 = y[0] + (x[i] - x[0]) * (y[1] - y[0]) / (x[1] - x[0])
                        if y[i] != 0:
                            if nearly_equal(a=y0, b=y[i]):
                                return True
                            else:
                                return False
                        else:
                            # avoid dividing by 0, but check we do extrapolate to 0 within the tolerance
                            if abs(y0) < epsilon:
                                return True
                            else:
                                return False
                    elif y[0] != y[1]:
                        x0 = x[0] + (y[i] - y[0]) * (x[1] - x[0]) / (y[1] - y[0])
                        if x[i] != 0:
                            if nearly_equal(a=x0, b=x[i]):
                                return True
                            else:
                                return False
                        else:
                            if abs(x0) < epsilon:
                                return True
                            else:
                                return False
                    else:
                        raise SpeciesError(
                            'Could not determine whether species {0} is linear, something must be wrong with its'
                            ' coordinates:\n{1}'.format(self.label, xyz))
        else:
            # this problem cannot be reduced, and must have a 3D treatment
            vector_list = []
            for i, _ in enumerate(x):
                # generate a vector list where each element in the list contains [v1, v2]
                # which are vectors (subtracting two points in space) between atoms A-B and B-C (or i, i-1 and i-1, i-2)
                if i > 1:  # so only start this at the third atom (index 2)
                    v1 = [x[i] - x[i - 1], y[i] - y[i - 1], z[i] - z[i - 1]]  # between points A, B
                    v2 = [x[i - 1] - x[i - 2], y[i - 1] - y[i - 2], z[i - 1] - z[i - 2]]  # between points B, C
                    vector_list.append([v1, v2])
            for v1, v2 in vector_list:
                if v1[0] and v2[0]:
                    ax = v1[0] / v2[0]  # This is how much the x coord of point C is stretched relative to the AB vector
                else:
                    ax = 0
                if v1[1] and v2[1]:
                    ay = v1[1] / v2[1]
                else:
                    ay = 0
                if v1[2] and v2[2]:
                    az = v1[2] / v2[2]
                else:
                    az = 0
                if ax and ay and not nearly_equal(ax, ay):
                    break
                if ax and az and not nearly_equal(ax, az):
                    break
                if ay and az and not nearly_equal(ay, az):
                    break
            else:
                return True
            return False

    def determine_number_of_atoms_from_xyz(self):
        """
        A helper function for determining the number of atoms from the XYZ geometry
        Useful for TSs where a 2D geometry isn't known
        """
        _, atoms, _, _, _ = get_xyz_matrix(self.initial_xyz)
        self.number_of_atoms = len(atoms)

    def make_ts_report(self):
        """A helper function to write content into the .ts_report attribute"""
        self.ts_report = ''
        if self.chosen_ts_method is not None:
            self.ts_report += 'TS method summary for {0} in {1}\n'.format(self.label, self.rxn_label)
            self.ts_report += 'Methods that successfully generated a TS guess:\n'
            if self.successful_methods:
                for successful_method in self.successful_methods:
                    self.ts_report += successful_method + ','
            if self.unsuccessful_methods:
                self.ts_report += '\nMethods that were unsuccessfully in generating a TS guess:\n'
                for unsuccessful_method in self.unsuccessful_methods:
                    self.ts_report += unsuccessful_method + ','
            self.ts_report += '\nThe method that generated the best TS guess and its output used for the' \
                              ' optimization: {0}'.format(self.chosen_ts_method)

    def mol_from_xyz(self, xyz=None):
        """
        Make sure atom order in self.mol corresponds to xyz
        Important for TS discovery and for identifying rotor indices

        This works by generating a molecule from the xyz and using the
        2D structure to confirm that the perceived molecule is correct.
        Resonance structures are generated and saved to ``self.mol_list``.
        """
        if xyz is None:
            xyz = self.final_xyz or self.initial_xyz

        if self.mol is not None:
            # self.mol should have come from another source, e.g. SMILES or yml
            original_mol = self.mol
            self.mol = molecules_from_xyz(xyz, multiplicity=self.multiplicity)[1]

            if self.mol is not None and not check_isomorphism(original_mol, self.mol):
                raise InputError('XYZ and the 2D graph representation of the Molecule are not isomorphic.\n'
                                 'Got xyz:\n{0}\n\nwhich corresponds to {1}\n{2}\n\nand: {3}\n{4}'.format(
                                   xyz, self.mol.toSMILES(), self.mol.toAdjacencyList(),
                                   original_mol.toSMILES(), original_mol.toAdjacencyList()))
        else:
            self.mol = molecules_from_xyz(xyz, multiplicity=self.multiplicity)[1]

        if self.mol_list is None:
            # Assign atom ids first, so they carry through to the resonance structures
            self.mol.assignAtomIDs()
            # The generate_resonance_structures method changes atom order
            # Make a copy so we don't disturb the original order from xyz
            self.mol_list = self.mol.copy(deep=True).generate_resonance_structures(keep_isomorphic=False,
                                                                                   filter_structures=True)
        order_atoms_in_mol_list(ref_mol=self.mol, mol_list=self.mol_list)


class TSGuess(object):
    """
    TSGuess class

    The user can define xyz directly, and the default `method` will be 'User guess'
    Alternatively, either ARC or the user can provide reactant/s and product/s geometries with a specified `method`
    `method` could be one of the following:
    - QST2
    - DEGSM
    - NEB
    - Kinbot: requires the RMG family, only works for H,C,O,S
    - AutoTST

    ====================== ============= ===============================================================================
    Attribute              Type          Description
    ====================== ============= ===============================================================================
    `xyz`                   ``str``      The 3D guess
    `method`                ``str''      The method/source used for the xyz guess
    `reactants_xyz`         ``list``     A list of tuples, each containing:
                                           (reactant label, reactant geometry in string format)
    `products_xyz`          ``list``     A list of tuples, each containing:
                                           (product label, product geometry in string format)
    `family`                ``str``      The RMG family that corresponds to the reaction, if applicable
    `rmg_reaction`          ``Reaction`` The RMG Reaction
    `t0'                    ``float``    Initial time of spawning the guess job
    `execution_time`        ``str``      Overall execution time for species
    `success`               ``bool``     Whether the TS guess method succeeded in generating an XYZ guess or not
    `energy`                ``float``    Relative energy of all TS conformers
    `index`                 ``int``      An index corresponding to the conformer jobs spawned for each TSGuess object
                                           Assigned only if self.success is ``True``
    ====================== ============= ===============================================================================

    """
    def __init__(self, method=None, reactants_xyz=None, products_xyz=None, family=None, xyz=None,
                 rmg_reaction=None, ts_dict=None):

        if ts_dict is not None:
            # Reading from a dictionary
            self.from_dict(ts_dict=ts_dict)
        else:
            # Not reading from a dictionary
            self.t0 = None
            self.index = None
            self.execution_time = None
            self.xyz = check_species_xyz(xyz)
            self.success = None
            self.energy = None
            self.method = method.lower() if method is not None else 'user guess'
            if 'user guess' in self.method:
                if self.xyz is None:
                    raise TSError('If no method is specified, an xyz guess must be given')
                self.success = True
                self.execution_time = 0
            if not ('user guess' in self.method or 'autotst' in self.method
                    or self.method in ['user guess'] + [tsm.lower() for tsm in default_ts_methods]):
                raise TSError('Unrecognized method. Should be either {0}. Got: {1}'.format(
                              ['User guess'] + default_ts_methods, self.method))
            self.reactants_xyz = reactants_xyz if reactants_xyz is not None else list()
            self.products_xyz = products_xyz if products_xyz is not None else list()
            self.rmg_reaction = rmg_reaction
            self.family = family
            # if self.family is None and self.method.lower() in ['kinbot', 'autotst']:
            #     raise TSError('No family specified for method {0}'.format(self.method))

    def as_dict(self):
        """A helper function for dumping this object as a dictionary in a YAML file for restarting ARC"""
        ts_dict = dict()
        ts_dict['t0'] = self.t0
        ts_dict['method'] = self.method
        ts_dict['success'] = self.success
        ts_dict['energy'] = self.energy
        ts_dict['index'] = self.index
        ts_dict['execution_time'] = self.execution_time
        if self.xyz:
            ts_dict['xyz'] = self.xyz
        if self.reactants_xyz:
            ts_dict['reactants_xyz'] = self.reactants_xyz
        if self.products_xyz:
            ts_dict['products_xyz'] = self.products_xyz
        if self.family is not None:
            ts_dict['family'] = self.family
        if self.rmg_reaction is not None:
            rxn = ' <=> '.join([' + '.join([spc.molecule[0].toSMILES() for spc in self.rmg_reaction.reactants]),
                               ' + '.join([spc.molecule[0].toSMILES() for spc in self.rmg_reaction.products])])
            ts_dict['rmg_reaction'] = rxn
        return ts_dict

    def from_dict(self, ts_dict):
        """
        A helper function for loading this object from a dictionary in a YAML file for restarting ARC
        """
        self.t0 = ts_dict['t0'] if 't0' in ts_dict else None
        self.index = ts_dict['index'] if 'index' in ts_dict else None
        self.xyz = ts_dict['xyz'] if 'xyz' in ts_dict else None
        self.success = ts_dict['success'] if 'success' in ts_dict else None
        self.energy = ts_dict['energy'] if 'energy' in ts_dict else None
        self.execution_time = ts_dict['execution_time'] if 'execution_time' in ts_dict else None
        self.method = ts_dict['method'].lower() if 'method' in ts_dict else 'user guess'
        if 'user guess' in self.method:
            if self.xyz is None:
                raise TSError('If no method is specified, an xyz guess must be given')
            self.success = self.success if self.success is not None else True
            self.execution_time = '0'
        if 'user guess' not in self.method\
                and self.method not in ['user guess'] + [tsm.lower() for tsm in default_ts_methods]:
            raise TSError('Unrecognized method. Should be either {0}. Got: {1}'.format(
                          ['User guess'] + default_ts_methods, self.method))
        self.reactants_xyz = ts_dict['reactants_xyz'] if 'reactants_xyz' in ts_dict else list()
        self.products_xyz = ts_dict['products_xyz'] if 'products_xyz' in ts_dict else list()
        self.family = ts_dict['family'] if 'family' in ts_dict else None
        if self.family is None and self.method.lower() in ['kinbot', 'autotst']:
            # raise TSError('No family specified for method {0}'.format(self.method))
            logging.warn('No family specified for method {0}'.format(self.method))
        self.rmg_reaction = ts_dict['rmg_reaction'] if 'rmg_reaction' in ts_dict else None
        if self.rmg_reaction is not None:
            plus = ' + '
            arrow = ' <=> '
            if not arrow in self.rmg_reaction:
                raise TSError('Could not read the reaction string. Expected to find " <=> ". '
                              'Got: {0}'.format(self.rmg_reaction))
            sides = self.rmg_reaction.split(arrow)
            reac = sides[0]
            prod = sides[1]
            if plus in reac:
                reac = reac.split(plus)
            else:
                reac = [reac]
            if plus in prod:
                prod = prod.split(plus)
            else:
                prod = [prod]
            reactants = list()
            products = list()
            for reactant in reac:
                reactants.append(Species().fromSMILES(str(reactant)))
            for product in prod:
                products.append(Species().fromSMILES(str(product)))
            self.rmg_reaction = Reaction(reactants=reactants, products=products)

    def execute_ts_guess_method(self):
        if self.method == 'user guess':
            pass
        elif self.method == 'qst2':
            self.qst2()
        elif self.method == 'degsm':
            self.degsm()
        elif self.method == 'neb':
            self.neb()
        elif self.method == 'kinbot':
            self.kinbot()
        elif self.method == 'autotst':
            self.autotst()
        else:
            raise TSError('Unrecognized method. Should be either {0}. Got: {1}'.format(
                          ['User guess'] + default_ts_methods, self.method))

    def autotst(self):
        """
        Determine a TS guess using AutoTST for the following RMG families:
        Current supported families are:
        - H_Abstraction
        Near-future supported families might be:
        - Disproportionation
        - R_Addition_MultipleBond
        - intra_H_migration
        """
        if not isinstance(self.rmg_reaction, Reaction):
            raise InputError('AutoTST requires an RMG Reaction object. Got: {0}'.format(type(self.rmg_reaction)))
        if self.family not in ['H_Abstraction']:
            logging.debug('AutoTST currently only works for H_Abstraction. Got: {0}'.format(self.family))
            self.xyz = ''
        else:
            self.xyz = atst.autotst(rmg_reaction=self.rmg_reaction, reaction_family=self.family)

    def qst2(self):
        """
        Determine a TS guess using QST2
        """
        self.success = False

    def degsm(self):
        """
        Determine a TS guess using DEGSM
        """
        self.success = False

    def neb(self):
        """
        Determine a TS guess using NEB
        """
        self.success = False

    def kinbot(self):
        """
        Determine a TS guess using Kinbot for RMG's unimolecular families
        """
        self.success = False


def _get_possible_conformers_rdkit(mol):
    """
    A helper function for conformer search
    Uses rdkit to automatically generate a set of len(mol.atoms)-3)*30 initial geometries, optimizes
    these geometries using MMFF94s, calculates the energies using MMFF94s
    and converts them back in terms of the RMG atom ordering
    Returns the coordinates and energies
    """
    if not isinstance(mol, (Molecule, RDMol)):
        raise SpeciesError('Can generate conformers to either an RDKit or RMG molecule. Got {0}'.format(type(mol)))
    rd_indx_map = dict()
    if isinstance(mol, RDMol):
        rd_mol = mol
    else:
        rd_mol, rd_inds = mol.toRDKitMol(removeHs=False, returnMapping=True)

        for k, atom in enumerate(mol.atoms):
            ind = rd_inds[atom]
            rd_indx_map[ind] = k
    if len(mol.atoms) > 50:
        Chem.AllChem.EmbedMultipleConfs(rd_mol, numConfs=500, randomSeed=1)
    elif len(mol.atoms) > 5:
        Chem.AllChem.EmbedMultipleConfs(rd_mol, numConfs=len(mol.atoms) * 3, randomSeed=1)
    else:
        Chem.AllChem.EmbedMultipleConfs(rd_mol, numConfs=50, randomSeed=1)
    energies = []
    xyzs = []
    for i in range(rd_mol.GetNumConformers()):
        v = 1
        while v == 1:
            v = Chem.AllChem.MMFFOptimizeMolecule(rd_mol, mmffVariant=str('MMFF94s'), confId=i,
                                             maxIters=500, ignoreInterfragInteractions=False)
        mp = Chem.AllChem.MMFFGetMoleculeProperties(rd_mol, mmffVariant=str('MMFF94s'))
        if mp is not None:
            ff = Chem.AllChem.MMFFGetMoleculeForceField(rd_mol, mp, confId=i)
            E = ff.CalcEnergy()
            energies.append(E)
            cf = rd_mol.GetConformer(i)
            xyz = []
            for j in range(cf.GetNumAtoms()):
                pt = cf.GetAtomPosition(j)
                xyz.append([pt.x, pt.y, pt.z])
            if isinstance(mol, Molecule):
                xyz = [xyz[rd_indx_map[j]] for j, _ in enumerate(xyz)]  # reorder
            xyzs.append(xyz)
    return xyzs, energies


def _get_possible_conformers_openbabel(mol):
    """
    A helper function for conformer search
    Uses OpenBabel to automatically generate set of len(mol.atoms)*10-3 initial geometries,
    optimizes these geometries using MMFF94s, calculates the energies using MMFF94s
    Returns the coordinates and energies
    """
    energies = []
    xyzs = []
    obmol, _ = toOBMol(mol, returnMapping=True)
    pybmol = pyb.Molecule(obmol)
    pybmol.make3D()
    obmol = pybmol.OBMol

    ff = ob.OBForceField.FindForceField("mmff94s")
    ff.Setup(obmol)
    if len(mol.atoms) > 50:
        ff.WeightedRotorSearch(500, 2000)
    elif len(mol.atoms) > 5:
        ff.WeightedRotorSearch(len(mol.atoms) * 10 - 3, 2000)
    else:
        ff.WeightedRotorSearch(50, 2000)
    ff.GetConformers(obmol)
    for n in range(obmol.NumConformers()):
        xyz = []
        obmol.SetConformer(n)
        ff.Setup(obmol)
        # ff.ConjugateGradientsTakeNSteps(1000)
        energies.append(ff.Energy())
        for atm in pybmol.atoms:
            xyz.append(list(atm.coords))
        xyzs.append(xyz)
    return xyzs, energies


def get_min_energy_conformer(xyzs, energies):
    minval = min(energies)
    minind = energies.index(minval)
    return xyzs[minind]


def find_internal_rotors(mol):
    """
    Locates the sets of indices corresponding to every internal rotor.
    Returns for each rotors the gaussian scan coordinates, the pivots and the top.
    """
    rotors = []
    for atom1 in mol.vertices:
        if atom1.isNonHydrogen():
            for atom2, bond in atom1.edges.items():
                if atom2.isNonHydrogen() and mol.vertices.index(atom1) < mol.vertices.index(atom2) \
                        and (bond.isSingle() or bond.isHydrogenBond()) and not mol.isBondInCycle(bond):
                    if len(atom1.edges) > 1 and len(atom2.edges) > 1:  # none of the pivotal atoms are terminal
                        rotor = dict()
                        # pivots:
                        rotor['pivots'] = [mol.vertices.index(atom1) + 1, mol.vertices.index(atom2) + 1]
                        # top:
                        top1, top2 = [], []
                        top1_has_heavy_atoms, top2_has_heavy_atoms = False, False
                        explored_atom_list = [atom2]
                        atom_list_to_explore = [atom1]
                        while len(atom_list_to_explore):
                            for atom in atom_list_to_explore:
                                top1.append(mol.vertices.index(atom) + 1)
                                for atom3, _ in atom.edges.items():
                                    if atom3.isHydrogen():
                                        # append H w/o further exploring
                                        top1.append(mol.vertices.index(atom3) + 1)
                                    elif atom3 not in explored_atom_list:
                                        top1_has_heavy_atoms = True
                                        atom_list_to_explore.append(atom3)  # explore it further
                                atom_list_to_explore.pop(atom_list_to_explore.index(atom))
                                explored_atom_list.append(atom)  # mark as explored
                        explored_atom_list, atom_list_to_explore = [atom1, atom2], [atom2]
                        while len(atom_list_to_explore):
                            for atom in atom_list_to_explore:
                                top2.append(mol.vertices.index(atom) + 1)
                                for atom3, _ in atom.edges.items():
                                    if atom3.isHydrogen():
                                        # append H w/o further exploring
                                        top2.append(mol.vertices.index(atom3) + 1)
                                    elif atom3 not in explored_atom_list:
                                        top2_has_heavy_atoms = True
                                        atom_list_to_explore.append(atom3)  # explore it further
                                atom_list_to_explore.pop(atom_list_to_explore.index(atom))
                                explored_atom_list.append(atom)  # mark as explored
                        if top1_has_heavy_atoms and not top2_has_heavy_atoms:
                            rotor['top'] = top2
                        elif top2_has_heavy_atoms and not top1_has_heavy_atoms:
                            rotor['top'] = top1
                        else:
                            rotor['top'] = top1 if len(top1) <= len(top2) else top2
                        # scan:
                        rotor['scan'] = []
                        heavy_atoms = []
                        hydrogens = []
                        for atom3, _ in atom1.edges.items():
                            if atom3.isHydrogen():
                                hydrogens.append(mol.vertices.index(atom3))
                            elif atom3 is not atom2:
                                heavy_atoms.append(mol.vertices.index(atom3))
                        smallest_index = len(mol.vertices)
                        if len(heavy_atoms):
                            for i in heavy_atoms:
                                if i < smallest_index:
                                    smallest_index = i
                        else:
                            for i in hydrogens:
                                if i < smallest_index:
                                    smallest_index = i
                        rotor['scan'].append(smallest_index + 1)
                        rotor['scan'].extend([mol.vertices.index(atom1) + 1, mol.vertices.index(atom2) + 1])
                        heavy_atoms = []
                        hydrogens = []
                        for atom3, _ in atom2.edges.items():
                            if atom3.isHydrogen():
                                hydrogens.append(mol.vertices.index(atom3))
                            elif atom3 is not atom1:
                                heavy_atoms.append(mol.vertices.index(atom3))
                        smallest_index = len(mol.vertices)
                        if len(heavy_atoms):
                            for i in heavy_atoms:
                                if i < smallest_index:
                                    smallest_index = i
                        else:
                            for i in hydrogens:
                                if i < smallest_index:
                                    smallest_index = i
                        rotor['scan'].append(smallest_index + 1)
                        rotor['success'] = None
                        rotor['invalidation_reason'] = ''
                        rotor['times_dihedral_set'] = 0
                        rotor['scan_path'] = ''
                        rotors.append(rotor)
    return rotors


def determine_occ(label, xyz, charge):
    """
    Determines the number of occupied orbitals for an MRCI calculation
    """
    electrons = 0
    for line in xyz.split('\n'):
        if line:
            atom = Atom(element=str(line.split()[0]))
            electrons += atom.number
    electrons -= charge


def nearly_equal(a, b, sig_fig=5):
    """
    A helper function to determine whether two floats are nearly equal.
    Can be replaced by math.isclose in Py3
    """
    return a == b or int(a*10**sig_fig) == int(b*10**sig_fig)


def determine_rotor_symmetry(rotor_path, label, pivots):
    """
    Determine the rotor symmetry number from the potential scan given in :list:`energies` in J/mol units
    Assumes the list represents a 360 degree scan
    str:`label` is the species name, used for logging and error messages
    list:`pivots` are the rotor's pivots, used for logging and error messages
    The *worst* resolution for each peak and valley is determined.
    The first criterion for a symmetric rotor is that the highest peak and the lowest peak must be within the
    worst peak resolution (and the same is checked for valleys).
    A second criterion for a symmetric rotor is that the highest and lowest peaks must be within 10% of
    the highest peak value. This is only applied if the highest peak is above 2 kJ/mol.
    """
    log = Log(path='')
    log.determine_qm_software(fullpath=rotor_path)
    energies, _ = log.software_log.loadScanEnergies()

    symmetry = None
    max_e = max(energies)
    if max_e > 2000:
        tol = 0.10 * max_e  # tolerance for the second criterion
    else:
        tol = max_e
    min_e = energies[0]
    for i, e in enumerate(energies):
        # sometimes the opt level and scan levels mismatch, causing the minimum to be close to 0 degrees, but not at 0
        if e < min_e:
            min_e = e
    peaks, valleys = list(), list()  # the peaks and valleys of the scan
    worst_peak_resolution, worst_valley_resolution = 0, 0
    for i, e in enumerate(energies):
        # identify peaks and valleys, and determine worst resolutions in the scan
        ip1 = cyclic_index_i_plus_1(i, len(energies))  # i Plus 1
        im1 = cyclic_index_i_minus_1(i)                # i Minus 1
        if i == 0 and energies[im1] == e:
            # If the first and last scan points have same energy, change im1
            im1 -= 1
            logging.debug('im1: {0}, ip1: {1}, em1: {2}, e: {3}, ep1: {4}'.format(
                im1, ip1, energies[im1], e, energies[ip1]))
        if e > energies[im1] and e > energies[ip1]:
            # this is a local peak
            if any([diff > worst_peak_resolution for diff in [e - energies[im1], e - energies[ip1]]]):
                worst_peak_resolution = max(e - energies[im1], e - energies[ip1])
            peaks.append(e)
        elif e < energies[im1] and e < energies[ip1]:
            # this is a local valley
            if any([diff > worst_valley_resolution for diff in [energies[im1] - e, energies[ip1] - e]]):
                worst_valley_resolution = max(energies[im1] - e, energies[ip1] - e)
            valleys.append(e)
    # The number of peaks and valley must always be the same (what goes up must come down), if it isn't then there's
    # something seriously wrong with the scan
    if len(peaks) != len(valleys):
        logging.error('Rotor of species {0} between pivots {1} does not have the same number'
                      ' of peaks ({2}) and valleys ({3}).'.format(label, pivots, len(peaks), len(valleys)))
        return len(peaks), max_e * 0.001  # this works for CC(=O)[O]
    min_peak = min(peaks)
    max_peak = max(peaks)
    min_valley = min(valleys)
    max_valley = max(valleys)
    # Criterion 1: worst resolution
    if max_peak - min_peak > worst_peak_resolution:
        # The rotor cannot be symmetric
        symmetry = 1
        reason = 'worst peak resolution criterion'
    elif max_valley - min_valley > worst_valley_resolution:
        # The rotor cannot be symmetric
        symmetry = 1
        reason = 'worst valley resolution criterion'
    # Criterion 2: 10% * max_peak
    elif max_peak - min_peak > tol:
        # The rotor cannot be symmetric
        symmetry = 1
        reason = '10% of the maximum peak criterion'
    else:
        # We declare this rotor as symmetric and the symmetry number is the number of peaks (and valleys)
        symmetry = len(peaks)
        reason = 'number of peaks and valleys, all within the determined resolution criteria'
    if symmetry not in [1, 2, 3]:
        logging.info('Determined symmetry number {0} for rotor of species {1} between pivots {2};'
                     ' you should make sure this makes sense'.format(symmetry, label, pivots))
    else:
        logging.info('Determined a symmetry number of {0} for rotor of species {1} between pivots {2}'
                     ' based on the {3}.'.format(symmetry, label, pivots, reason))
    return symmetry, max_e * 0.001  # max_e in kJ/mol


def cyclic_index_i_plus_1(i, length):
    return i + 1 if i + 1 < length else 0


def cyclic_index_i_minus_1(i):
    return i - 1 if i - 1 > 0 else -1


def determine_rotor_type(rotor_path):
    """
    Determine whether this rotor should be treated as a HinderedRotor of a FreeRotor
    according to it's maximum peak
    """
    log = Log(path='')
    log.determine_qm_software(fullpath=rotor_path)
    energies, _ = log.software_log.loadScanEnergies()
    max_val = max(energies) * 0.001  # convert to kJ/mol (Arkane used SI)
    return 'FreeRotor' if max_val < minimum_barrier else 'HinderedRotor'


def check_species_xyz(xyz):
    """
    First check whether xyz represents a file path or not. If so, parse it first.
    Then, standardize the xyz format using converter.standardize_xyz_string
    """
    if xyz is not None:
        if os.path.isfile(xyz):
            # check whether xyz is a file path
            xyz = parse_xyz_from_file(xyz)
        return standardize_xyz_string(xyz)
    return None
